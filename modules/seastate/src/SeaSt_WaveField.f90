MODULE SeaSt_WaveField

USE GridInterp
USE SeaSt_WaveField_Types
USE GridInterp_Types

IMPLICIT NONE

PRIVATE

! Public functions and subroutines
PUBLIC WaveField_GetNodeWaveElev1
PUBLIC WaveField_GetNodeWaveElev2
PUBLIC WaveField_GetNodeTotalWaveElev
PUBLIC WaveField_GetNodeWaveNormal
PUBLIC WaveField_GetNodeWaveKin
PUBLIC WaveField_GetNodeWaveVel
PUBLIC WaveField_GetWaveKin

CONTAINS

!-------------------- Subroutine for wave elevation ------------------!
function WaveField_GetNodeWaveElev1( WaveField, WaveField_m, Time, pos, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(*)  ! Position at which free-surface elevation is to be calculated. Third entry ignored if present.
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(SiKi)                                        :: WaveField_GetNodeWaveElev1
   real(SiKi)                                        :: Zeta
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeWaveElev1'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   IF (ALLOCATED(WaveField%WaveElev1)) THEN
      CALL WaveField_Interp_Setup3D( Time, pos, WaveField%SrfGridParams, WaveField_m, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Zeta = GridInterp3D(WaveField%WaveElev1,WaveField_m)
   ELSE
      Zeta = 0.0_SiKi
   END IF

   WaveField_GetNodeWaveElev1 = Zeta

end function WaveField_GetNodeWaveElev1


function WaveField_GetNodeWaveElev2( WaveField, WaveField_m, Time, pos, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(*)  ! Position at which free-surface elevation is to be calculated. Third entry ignored if present.
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(SiKi)                                        :: WaveField_GetNodeWaveElev2
   real(SiKi)                                        :: Zeta
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeWaveElev2'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   IF (ALLOCATED(WaveField%WaveElev2)) THEN
      CALL WaveField_Interp_Setup3D( Time, pos, WaveField%SrfGridParams, WaveField_m, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Zeta = GridInterp3D(WaveField%WaveElev2,WaveField_m)
   ELSE
      Zeta = 0.0_SiKi
   END IF

   WaveField_GetNodeWaveElev2 = Zeta

end function WaveField_GetNodeWaveElev2


FUNCTION WaveField_GetNodeTotalWaveElev( WaveField, WaveField_m, Time, pos, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(*)  ! Position at which free-surface elevation is to be calculated. Third entry ignored if present.
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(SiKi)                                        :: WaveField_GetNodeTotalWaveElev
   real(SiKi)                                        :: Zeta1, Zeta2
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeTotalWaveElev'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   Zeta1 = WaveField_GetNodeWaveElev1( WaveField, WaveField_m, Time, pos, ErrStat2, ErrMsg2 ); if (Failed()) return;
   Zeta2 = WaveField_GetNodeWaveElev2( WaveField, WaveField_m, Time, pos, ErrStat2, ErrMsg2 ); if (Failed()) return;
   WaveField_GetNodeTotalWaveElev = Zeta1 + Zeta2

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END FUNCTION WaveField_GetNodeTotalWaveElev


SUBROUTINE WaveField_GetNodeWaveNormal( WaveField, WaveField_m, Time, pos, n, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(*)  ! Position at which free-surface normal is to be calculated. Third entry ignored if present.
   real(ReKi),                         intent(  out) :: n(3)    ! Free-surface normal vector
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(SiKi)                                        :: slope(2)
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeWaveNormal'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   call GridInterpSetupN( (/Real(Time,ReKi),pos(1),pos(2)/), WaveField%SrfGridParams, WaveField_m, ErrStat2, ErrMsg2 )
   slope = GridInterpS( WaveField%WaveElev1, WaveField%SrfGridParams, WaveField_m )
   if (ALLOCATED(WaveField%WaveElev2)) then
      slope = slope + GridInterpS( WaveField%WaveElev2, WaveField%SrfGridParams, WaveField_m )
   end if

   n = Real( (/-slope(1),-slope(2),1.0_SiKi/), ReKi)
   n = n / TwoNorm(n)

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END SUBROUTINE WaveField_GetNodeWaveNormal


!-------------------- Subroutine for full wave field kinematics --------------------!
SUBROUTINE WaveField_GetNodeWaveKin( WaveField, WaveField_m, Time, pos, forceNodeInWater, nodeInWater, WaveElev1, WaveElev2, WaveElev, FDynP, FV, FA, FAMCF, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(3)
   logical,                            intent(in   ) :: forceNodeInWater
   real(SiKi),                         intent(  out) :: WaveElev1
   real(SiKi),                         intent(  out) :: WaveElev2
   real(SiKi),                         intent(  out) :: WaveElev
   real(SiKi),                         intent(  out) :: FV(3)
   real(SiKi),                         intent(  out) :: FA(3)
   real(SiKi),                         intent(  out) :: FAMCF(3)
   real(SiKi),                         intent(  out) :: FDynP
   integer(IntKi),                     intent(  out) :: nodeInWater
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(ReKi)                                        :: posXY(2), posPrime(3), posXY0(3)
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeWaveKin'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   posXY    = pos(1:2)
   posXY0   = (/pos(1),pos(2),0.0_ReKi/)
   FAMCF(:) = 0.0

   ! Wave elevation
   WaveElev1 = WaveField_GetNodeWaveElev1( WaveField, WaveField_m, Time, pos, ErrStat2, ErrMsg2 ); if (Failed()) return;
   WaveElev2 = WaveField_GetNodeWaveElev2( WaveField, WaveField_m, Time, pos, ErrStat2, ErrMsg2 ); if (Failed()) return;
   WaveElev  = WaveElev1 + WaveElev2

   IF (WaveField%WaveStMod == 0) THEN ! No wave stretching

      IF ( pos(3) <= 0.0_ReKi) THEN ! Node is at or below the SWL
         nodeInWater = 1_IntKi
         ! Use location to obtain interpolated values of kinematics
         CALL WaveField_Interp_Setup4D( Time, pos, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
         FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )
         FA(:) = GridInterp4DVec( WaveField%WaveAcc,  WaveField_m )
         FDynP = GridInterp4D   ( WaveField%WaveDynP, WaveField_m )
         IF ( ALLOCATED(WaveField%WaveAccMCF) ) THEN
            FAMCF(:) = GridInterp4DVec( WaveField%WaveAccMCF, WaveField_m )
         END IF
      ELSE ! Node is above the SWL
         nodeInWater = 0_IntKi
         FV(:)       = 0.0
         FA(:)       = 0.0
         FDynP       = 0.0
         FAMCF(:)    = 0.0
      END IF

   ELSE ! Wave stretching enabled

      IF ( (pos(3) <= WaveElev) .OR. forceNodeInWater ) THEN ! Node is submerged

         nodeInWater = 1_IntKi

         IF ( WaveField%WaveStMod < 3 ) THEN ! Vertical or extrapolated wave stretching

            IF ( pos(3) <= 0.0_SiKi) THEN ! Node is below the SWL - evaluate wave dynamics as usual

               ! Use location to obtain interpolated values of kinematics
               CALL WaveField_Interp_Setup4D( Time, pos, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
               FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )
               FA(:) = GridInterp4DVec( WaveField%WaveAcc,  WaveField_m )
               FDynP = GridInterp4D   ( WaveField%WaveDynP, WaveField_m )
               IF ( ALLOCATED(WaveField%WaveAccMCF) ) THEN
                  FAMCF(:) = GridInterp4DVec( WaveField%WaveAccMCF, WaveField_m )
               END IF

            ELSE ! Node is above SWL - need wave stretching

               ! Vertical wave stretching
               CALL WaveField_Interp_Setup4D( Time, posXY0, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
               FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )
               FA(:) = GridInterp4DVec( WaveField%WaveAcc,  WaveField_m )
               FDynP = GridInterp4D   ( WaveField%WaveDynP, WaveField_m )
               IF ( ALLOCATED(WaveField%WaveAccMCF) ) THEN
                  FAMCF(:) = GridInterp4DVec( WaveField%WaveAccMCF, WaveField_m )
               END IF

               ! Extrapoled wave stretching
               IF (WaveField%WaveStMod == 2) THEN
                  CALL WaveField_Interp_Setup3D( Time, posXY, WaveField%SrfGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
                  FV(:) = FV(:) + GridInterp3DVec( WaveField%PWaveVel0,  WaveField_m ) * pos(3)
                  FA(:) = FA(:) + GridInterp3DVec( WaveField%PWaveAcc0,  WaveField_m ) * pos(3)
                  FDynP = FDynP + GridInterp3D   ( WaveField%PWaveDynP0, WaveField_m ) * pos(3)
                  IF ( ALLOCATED(WaveField%WaveAccMCF) ) THEN
                     FAMCF(:) = FAMCF(:) + GridInterp3DVec( WaveField%PWaveAccMCF0, WaveField_m ) * pos(3)
                  END IF
               END IF

            END IF ! Node is submerged

         ELSE ! Wheeler stretching - no need to check whether the node is above or below SWL

            ! Map the node z-position linearly from [-EffWtrDpth,m%WaveElev(j)] to [-EffWtrDpth,0]
            posPrime    = pos
            posPrime(3) = WaveField%EffWtrDpth*(WaveField%EffWtrDpth+pos(3))/(WaveField%EffWtrDpth+WaveElev)-WaveField%EffWtrDpth
            posPrime(3) = MIN( posPrime(3), 0.0_ReKi) ! Clamp z-position to zero. Needed when forceNodeInWater=.TRUE.

            ! Obtain the wave-field variables by interpolation with the mapped position.
            CALL WaveField_Interp_Setup4D( Time, posPrime, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
            FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )
            FA(:) = GridInterp4DVec( WaveField%WaveAcc,  WaveField_m )
            FDynP = GridInterp4D   ( WaveField%WaveDynP, WaveField_m )
            IF ( ALLOCATED(WaveField%WaveAccMCF) ) THEN
               FAMCF(:) = GridInterp4DVec( WaveField%WaveAccMCF, WaveField_m )
            END IF
         END IF

      ELSE ! Node is out of water - zero-out all wave dynamics

         nodeInWater = 0_IntKi
         FV(:)       = 0.0
         FA(:)       = 0.0
         FDynP       = 0.0
         FAMCF(:)    = 0.0

      END IF ! If node is in or out of water

   END IF ! If wave stretching is on or off

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END SUBROUTINE WaveField_GetNodeWaveKin


!-------------------- Subroutine for wave field velocity only --------------------!
SUBROUTINE WaveField_GetNodeWaveVel( WaveField, WaveField_m, Time, pos, forceNodeInWater, nodeInWater, FV, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(3)
   logical,                            intent(in   ) :: forceNodeInWater
   integer(IntKi),                     intent(  out) :: nodeInWater
   real(SiKi),                         intent(  out) :: FV(3)
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   real(SiKi)                                        :: WaveElev
   real(ReKi)                                        :: posXY(2), posPrime(3), posXY0(3)
   character(*),                       parameter     :: RoutineName = 'WaveField_GetNodeWaveVel'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   ErrStat   = ErrID_None
   ErrMsg    = ""

   posXY    = pos(1:2)
   posXY0   = (/pos(1),pos(2),0.0_ReKi/)

   ! Wave elevation
   WaveElev  = WaveField_GetNodeTotalWaveElev( WaveField, WaveField_m, Time, pos, ErrStat2, ErrMsg2 ); if (Failed()) return;

   IF (WaveField%WaveStMod == 0) THEN ! No wave stretching

      IF ( pos(3) <= 0.0_ReKi) THEN ! Node is at or below the SWL
         nodeInWater = 1_IntKi
         ! Use location to obtain interpolated values of kinematics
         CALL WaveField_Interp_Setup4D( Time, pos, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
         FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )
      ELSE ! Node is above the SWL
         nodeInWater = 0_IntKi
         FV(:)       = 0.0
      END IF

   ELSE ! Wave stretching enabled

      IF ( (pos(3) <= WaveElev) .OR. forceNodeInWater ) THEN ! Node is submerged

         nodeInWater = 1_IntKi

         IF ( WaveField%WaveStMod < 3 ) THEN ! Vertical or extrapolated wave stretching

            IF ( pos(3) <= 0.0_SiKi) THEN ! Node is below the SWL - evaluate wave dynamics as usual

               ! Use location to obtain interpolated values of kinematics
               CALL WaveField_Interp_Setup4D( Time, pos, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
               FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )

            ELSE ! Node is above SWL - need wave stretching

               ! Vertical wave stretching
               CALL WaveField_Interp_Setup4D( Time, posXY0, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
               FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )

               ! Extrapoled wave stretching
               IF (WaveField%WaveStMod == 2) THEN
                  CALL WaveField_Interp_Setup3D( Time, posXY, WaveField%SrfGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
                  FV(:) = FV(:) + GridInterp3DVec( WaveField%PWaveVel0, WaveField_m ) * pos(3)
               END IF

            END IF ! Node is submerged

         ELSE ! Wheeler stretching - no need to check whether the node is above or below SWL

            ! Map the node z-position linearly from [-EffWtrDpth,m%WaveElev(j)] to [-EffWtrDpth,0]
            posPrime    = pos
            posPrime(3) = WaveField%EffWtrDpth*(WaveField%EffWtrDpth+pos(3))/(WaveField%EffWtrDpth+WaveElev)-WaveField%EffWtrDpth
            posPrime(3) = MIN( posPrime(3), 0.0_ReKi) ! Clamp z-position to zero. Needed when forceNodeInWater=.TRUE.

            ! Obtain the wave-field variables by interpolation with the mapped position.
            CALL WaveField_Interp_Setup4D( Time, posPrime, WaveField%GridDepth, WaveField%VolGridParams, WaveField_m, ErrStat2, ErrMsg2 ); if (Failed()) return;
            FV(:) = GridInterp4DVec( WaveField%WaveVel,  WaveField_m )

         END IF

      ELSE ! Node is out of water - zero-out all wave dynamics

         nodeInWater = 0_IntKi
         FV(:)       = 0.0

      END IF ! If node is in or out of water

   END IF ! If wave stretching is on or off

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END SUBROUTINE WaveField_GetNodeWaveVel


SUBROUTINE WaveField_GetWaveKin( WaveField, WaveField_m, Time, pos, forceNodeInWater, nodeInWater, WaveElev1, WaveElev2, WaveElev, FDynP, FV, FA, FAMCF, ErrStat, ErrMsg )
   type(SeaSt_WaveFieldType),          intent(in   ) :: WaveField
   type(GridInterp_MiscVarType),       intent(inout) :: WaveField_m
   real(DbKi),                         intent(in   ) :: Time
   real(ReKi),                         intent(in   ) :: pos(:,:)
   logical,                            intent(in   ) :: forceNodeInWater
   real(SiKi),                         intent(  out) :: WaveElev1(:)
   real(SiKi),                         intent(  out) :: WaveElev2(:)
   real(SiKi),                         intent(  out) :: WaveElev(:)
   real(ReKi),                         intent(  out) :: FV(:,:)
   real(ReKi),                         intent(  out) :: FA(:,:)
   real(ReKi),                         intent(  out) :: FAMCF(:,:)
   real(ReKi),                         intent(  out) :: FDynP(:)
   integer(IntKi),                     intent(  out) :: nodeInWater(:)
   integer(IntKi),                     intent(  out) :: ErrStat ! Error status of the operation
   character(*),                       intent(  out) :: ErrMsg  ! Error message if errStat /= ErrID_None

   character(*),                       parameter     :: RoutineName = 'WaveField_GetWaveKin'
   integer(IntKi)                                    :: errStat2
   character(ErrMsgLen)                              :: errMsg2

   integer(IntKi)                                    :: NumPoints, i
   real(SiKi)                                        :: FDynP_node, FV_node(3), FA_node(3), FAMCF_node(3)

   ErrStat   = ErrID_None
   ErrMsg    = ""

   NumPoints = size(pos, dim=2)
   DO i = 1, NumPoints
      CALL WaveField_GetNodeWaveKin( WaveField, WaveField_m, Time, pos(:,i), forceNodeInWater, nodeInWater(i), WaveElev1(i), WaveElev2(i), WaveElev(i), FDynP_node, FV_node, FA_node, FAMCF_node, ErrStat2, ErrMsg2 )
      if (Failed()) return;
      FDynP(i) = REAL(FDynP_node,ReKi)
      FV(:, i) = REAL(FV_node,   ReKi)
      FA(:, i) = REAL(FA_node,   ReKi)
      IF (ALLOCATED(WaveField%WaveAccMCF)) THEN
         FAMCF(:,i) = REAL(FAMCF_node,ReKi)
      END IF
   END DO

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
end subroutine WaveField_GetWaveKin


!----------------------------------------------------------------------------------------------------
! Interpolation related functions
!----------------------------------------------------------------------------------------------------

!====================================================================================================
!> This routine sets up interpolation of a 3-d or 4-d dataset.
!! This method is described here: http://rjwagner49.com/Mathematics/Interpolation.pdf
subroutine WaveField_Interp_Setup3D( Time, Position, p, m, ErrStat, ErrMsg )
   real(DbKi),                          intent(in   )  :: Time              !< Time from the start of the simulation
   real(ReKi),                          intent(in   )  :: Position(2)       !< Array of XY coordinates, 2
   type(GridInterp_ParameterType),      intent(in   )  :: p                 !< Parameters
   type(GridInterp_MiscVarType),        intent(inout)  :: m                 !< MiscVars
   integer(IntKi),                      intent(  out)  :: ErrStat           !< Error status
   character(*),                        intent(  out)  :: ErrMsg            !< Error message if ErrStat /= ErrID_None

   character(*), parameter              :: RoutineName = 'WaveField_Interp_Setup3D'
   integer(IntKi)                       :: ErrStat2
   character(ErrMsgLen)                 :: ErrMsg2

   ErrStat = ErrID_None
   ErrMsg  = ""

   CALL GridInterpSetup3D((/Real(Time,ReKi),Position(1),Position(2)/), p, m, ErrStat2, ErrMsg2 )
     if (Failed()) return;

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END Subroutine WaveField_Interp_Setup3D

subroutine WaveField_Interp_Setup4D( Time, Position, GridDepth, p, m, ErrStat, ErrMsg )
   real(DbKi),                          intent(in   )  :: Time              !< Time from the start of the simulation
   real(ReKi),                          intent(in   )  :: Position(3)       !< Array of XYZ coordinates, 3
   real(SiKi),                          intent(in   )  :: GridDepth         !< Depth (>0) of the wave grid below SWL
   type(GridInterp_ParameterType),      intent(in   )  :: p                 !< Parameters
   type(GridInterp_MiscVarType),        intent(inout)  :: m                 !< MiscVars
   integer(IntKi),                      intent(  out)  :: ErrStat           !< Error status
   character(*),                        intent(  out)  :: ErrMsg            !< Error message if ErrStat /= ErrID_None

   real(ReKi)                           :: kz

   character(*), parameter              :: RoutineName = 'WaveField_Interp_Setup4D'
   integer(IntKi)                       :: ErrStat2
   character(ErrMsgLen)                 :: ErrMsg2

   ErrStat = ErrID_None
   ErrMsg  = ""

   ! Map physical z-coordinate to grid index space
   kz = 0.5_ReKi*Pi - acos( max( -1.0_ReKi, min( 1.0_ReKi, 1.0_ReKi + (Position(3) / GridDepth) ) ) )
   call GridInterpSetup4D( (/Real(Time,ReKi),Position(1),Position(2),kz/), p, m, ErrStat, ErrMsg )

contains
   logical function Failed()
      call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
   end function
END Subroutine WaveField_Interp_Setup4D


END MODULE SeaSt_WaveField
