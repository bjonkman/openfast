!STARTOFREGISTRYGENERATEDFILE 'GridInterp_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! GridInterp_Types
!.................................................................................................................................
! This file is part of GridInterp.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in GridInterp. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE GridInterp_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  GridInterp_ParameterType  =======
  TYPE, PUBLIC :: GridInterp_ParameterType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n = 0_IntKi      !< number of evenly-spaced grid points in each dimension [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta = 0.0_ReKi      !< size between 2 consecutive grid points in each grid direction [-]
    REAL(ReKi) , DIMENSION(1:4)  :: pZero = 0.0_ReKi      !< fixed position of the grid starting corner (i.e., XYZW coordinates of m%V(0,0,0,0,:)) [-]
    LOGICAL , DIMENSION(1:4)  :: IsPeriodic = .false.      !< flag to indicate whether this dimension should be treated as periodic [-]
  END TYPE GridInterp_ParameterType
! =======================
! =========  GridInterp_MiscVarType  =======
  TYPE, PUBLIC :: GridInterp_MiscVarType
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4)  :: N3D = 0.0_ReKi      !< this is the weights for 3D grid values [-]
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4,1:4)  :: N4D = 0.0_ReKi      !< this is the weights for 4D grid values [-]
    INTEGER(IntKi) , DIMENSION(1:4,1:4)  :: Indx = 0_IntKi      !< this is the neighboring node index into the grid [-]
    LOGICAL  :: FirstWarn_Clamp = .true.      !< used to avoid too many 'Position has been clamped to the grid boundary' warning messages  [-]
  END TYPE GridInterp_MiscVarType
! =======================
CONTAINS

subroutine GridInterp_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(GridInterp_ParameterType), intent(in) :: SrcParamData
   type(GridInterp_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'GridInterp_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%n = SrcParamData%n
   DstParamData%delta = SrcParamData%delta
   DstParamData%pZero = SrcParamData%pZero
   DstParamData%IsPeriodic = SrcParamData%IsPeriodic
end subroutine

subroutine GridInterp_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(GridInterp_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'GridInterp_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine GridInterp_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(GridInterp_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'GridInterp_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%n)
   call RegPack(RF, InData%delta)
   call RegPack(RF, InData%pZero)
   call RegPack(RF, InData%IsPeriodic)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine GridInterp_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(GridInterp_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'GridInterp_UnPackParam'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%n); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%delta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pZero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsPeriodic); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine GridInterp_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(GridInterp_MiscVarType), intent(in) :: SrcMiscData
   type(GridInterp_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'GridInterp_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMiscData%N3D = SrcMiscData%N3D
   DstMiscData%N4D = SrcMiscData%N4D
   DstMiscData%Indx = SrcMiscData%Indx
   DstMiscData%FirstWarn_Clamp = SrcMiscData%FirstWarn_Clamp
end subroutine

subroutine GridInterp_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(GridInterp_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'GridInterp_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine GridInterp_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(GridInterp_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'GridInterp_PackMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%N3D)
   call RegPack(RF, InData%N4D)
   call RegPack(RF, InData%Indx)
   call RegPack(RF, InData%FirstWarn_Clamp)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine GridInterp_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(GridInterp_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'GridInterp_UnPackMisc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%N3D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%N4D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FirstWarn_Clamp); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE GridInterp_Types
!ENDOFREGISTRYGENERATEDFILE
