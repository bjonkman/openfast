!STARTOFREGISTRYGENERATEDFILE 'WaveTank_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WaveTank_Types
!.................................................................................................................................
! This file is part of WaveTank.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WaveTank. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WaveTank_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE ISO_C_BINDING
USE NWTC_Library
IMPLICIT NONE
! =========  SimType  =======
  TYPE, PUBLIC :: SimType
    REAL(c_double)  :: DT = 0.0_R8Ki      !< timestep [-]
    REAL(c_double)  :: TMax = 0.0_R8Ki      !< Max sim time [-]
    INTEGER(c_int)  :: MHK = 0_IntKi      !< MHK turbine type (switch) {0=Not an MHK turbine; 1=Fixed MHK turbine; 2=Floating MHK turbine} [(-)]
    INTEGER(c_int)  :: InterpOrd = 1      !< Interpolation order [-]
    REAL(c_float)  :: ScaleFact = 1 
    REAL(c_float)  :: DensFact = 1      !< ratio of density - Density_full/Density_model (rho_F/rho_M).  Used with Froude scaling of forces/moments [(-)]
    INTEGER(c_int)  :: DebugLevel = 0_IntKi      !< Debug level for outputs [-]
    character(1024)  :: OutRootName      !< Rootname for outputs [-]
  END TYPE SimType
! =======================
! =========  EnvType  =======
  TYPE, PUBLIC :: EnvType
    REAL(c_float)  :: Gravity = 0.0_R4Ki      !< gravitational constant (positive for down) [(m/s^2)]
    REAL(c_float)  :: WtrDens = 0.0_R4Ki      !< Water density [(kg/m^3)]
    REAL(c_float)  :: WtrVisc = 0.0_R4Ki      !< fluid viscosity [(m^2/s)]
    REAL(c_float)  :: SpdSound = 0.0_R4Ki      !< Speed of sound in working fluid [(m/s)]
    REAL(c_float)  :: Patm = 0.0_R4Ki      !< Atmospheric pressure  [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: Pvap = 0.0_R4Ki      !< Vapour pressure of working fluid [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: WtrDpth = 0.0_R4Ki      !< Water depth [(m)]
    REAL(c_float)  :: MSL2SWL = 0.0_R4Ki      !< Mean sea level to still water level [(m)]
  END TYPE EnvType
! =======================
! =========  TurbConfigType  =======
  TYPE, PUBLIC :: TurbConfigType
    INTEGER(IntKi)  :: NumBl = 0_IntKi      !< Number of blades [(-)]
    REAL(ReKi)  :: HubRad = 0.0_ReKi      !< The distance from the rotor apex to the blade root [(m)]
    REAL(ReKi)  :: PreCone = 0.0_ReKi      !< Blade cone angle [(deg)]
    REAL(ReKi)  :: OverHang = 0.0_ReKi      !< Distance from yaw axis to rotor apex [3 blades] or teeter pin [2 blades] [(m)]
    REAL(ReKi)  :: ShftTilt = 0.0_ReKi      !< Rotor shaft tilt angle [(deg)]
    REAL(ReKi)  :: Twr2Shft = 0.0_ReKi      !< Vertical distance from the tower-top to the rotor shaft [(m)]
    REAL(ReKi)  :: TowerHt = 0.0_ReKi      !< Height of tower relative MSL [(m)]
    REAL(ReKi) , DIMENSION(1:3)  :: TowerBsPt = 0.0_ReKi      !< Tower base location relative to MSL. Consider absolute difference to PtfmRef [floating MHK] [(m)]
    REAL(ReKi) , DIMENSION(1:3)  :: PtfmRefPos = 0.0_ReKi      !< Location of platform reference point, relative to MSL.  Motions and loads all connect to this point [(m)]
    REAL(ReKi) , DIMENSION(1:3)  :: PtfmRefOrient = 0.0_ReKi      !< Orientation of platform reference point, Euler angle set of roll,pitch,yaw [(rad)]
  END TYPE TurbConfigType
! =======================
! =========  TurbInitCondType  =======
  TYPE, PUBLIC :: TurbInitCondType
    REAL(ReKi)  :: RotSpeed = 0.0_ReKi      !< Rotor speed [(RPM)]
    REAL(ReKi)  :: NacYaw = 0.0_ReKi      !< Initial or fixed nacelle-yaw angle - read as deg, convert to rad [(rad)]
    REAL(ReKi)  :: BldPitch = 0.0_ReKi      !< Fixed blade pitch for full simulation - read as deg, convert to rad [(rad)]
    REAL(ReKi)  :: Azimuth = 0      !< Initial azimuth (actual azimuth calculated and not stored) - read as deg, convert to rad [(rad)]
  END TYPE TurbInitCondType
! =======================
! =========  WaveBuoyType  =======
  TYPE, PUBLIC :: WaveBuoyType
    REAL(ReKi) , DIMENSION(1:2)  :: XYLoc = 0.0_ReKi      !< Location of the wave elevation measurement buoy. SeaState data returned at every timestep at this location [(m)]
  END TYPE WaveBuoyType
! =======================
! =========  OutFilesType  =======
  TYPE, PUBLIC :: OutFilesType
    LOGICAL  :: SendScreenToFile = .false.      !< send to file <OutRootName>.screen.log if true [(-)]
    INTEGER(c_int)  :: OutFile = 0_IntKi      !< 0: no output file of channels, 1: output file in text format (at DT) [(-)]
    character(20)  :: OutFmt      !< Format used for text tabular output, excluding the time channel. (quoted string) [(-)]
  END TYPE OutFilesType
! =======================
! =========  VizType  =======
  TYPE, PUBLIC :: VizType
    INTEGER(c_int)  :: WrVTK = 0_IntKi      !< Write VTK? [-]
    INTEGER(c_int)  :: WrVTK_type = 0_IntKi      !< Write VTK outputs as [1: surface, 2: lines, 3: both] [-]
    REAL(c_double)  :: WrVTK_DT = 0.0_R8Ki      !< Time step between VTK writes [-]
    character(1024)  :: WrVTK_dir      !< Directory for VTK writing [-]
    REAL(c_float) , DIMENSION(1:6)  :: VTKNacDim = 0.0_R4Ki      !< Nacelle dimension passed in for VTK surface rendering [0,y0,z0,Lx,Ly,Lz] [(m)]
    INTEGER(IntKi)  :: Twidth = 6      !< Time width -- hard coded for now [(-)]
  END TYPE VizType
! =======================
! =========  ModSettings  =======
  TYPE, PUBLIC :: ModSettings
    character(1024)  :: SS_InputFile      !< SeaState   input file [(-)]
    REAL(DbKi)  :: WaveTimeShift = 0.0_R8Ki      !< Shift the SeaState wavetime by this amount (for phase shifting waves to match tank) [(s)]
    character(1024)  :: MD_InputFile      !< MoorDyn    input file [(-)]
    character(1024)  :: AD_InputFile      !< AeroDyn    input file [(-)]
    character(1024)  :: IfW_InputFile      !< InflowWind input file [(-)]
  END TYPE ModSettings
! =======================
! =========  SimSettingsType  =======
  TYPE, PUBLIC :: SimSettingsType
    TYPE(SimType)  :: Sim      !< Simulation settings [-]
    TYPE(EnvType)  :: Env      !< Environment settings [-]
    TYPE(TurbConfigType)  :: TrbCfg      !< Turbine configuration [-]
    TYPE(TurbInitCondType)  :: TrbInit      !< Turbine initial operating point [-]
    TYPE(WaveBuoyType)  :: WaveBuoy      !< Wave elevation buoy locat (x-y) [(m)]
    TYPE(OutFilesType)  :: Outs      !< Output settings [-]
    TYPE(VizType)  :: Viz      !< Vizualization settings [-]
    TYPE(ModSettings)  :: ModSettings      !< Input files for each module [-]
  END TYPE SimSettingsType
! =======================
! =========  CalcStepIOdataType  =======
  TYPE, PUBLIC :: CalcStepIOdataType
    REAL(c_double)  :: Time_c = 0.0_R8Ki      !< IN:  time [(s)]
    REAL(c_float) , DIMENSION(1:6)  :: PosAng_c = 0.0_R4Ki      !< IN:  Position + Euler Ang [x,y,z,phi,theta,psi] [[(m) (rad)]]
    REAL(c_float) , DIMENSION(1:6)  :: Vel_c = 0.0_R4Ki      !< IN:  Velocity             [Vx,Vy,Vz,RVx,RVy,RVz] [[(m/s) (rad/s)]]
    REAL(c_float) , DIMENSION(1:6)  :: Acc_c = 0.0_R4Ki      !< IN:  Acceleration         [Ax,Ay,Az,RAx,RAy,RAz] [[(m/s^2) (rad/s^2)]]
    REAL(c_float) , DIMENSION(1:6)  :: FrcMom_c = 0.0_R4Ki      !< OUT: Acceleration         [Fx,Fy,Fz,Mx,My,Mz] [[(N) (N-m)]]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_SS = 0.0_ReKi      !< calculated forces/moments from SS [-]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_MD = 0.0_ReKi      !< calculated forces/moments from MD [-]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_ADI = 0.0_ReKi      !< calculated forces/moments from ADI [-]
    REAL(ReKi)  :: BuoyWaveElev = 0.0_ReKi      !< calculated wave elevation at buoy [-]
  END TYPE CalcStepIOdataType
! =======================
! =========  WrOutputDataType  =======
  TYPE, PUBLIC :: WrOutputDataType
    INTEGER(IntKi)  :: NumChans_cbind = 0      !< Number of output channels from c-bind [-]
    INTEGER(IntKi)  :: NumChans_SS = 0      !< Number of output channels from SS [-]
    INTEGER(IntKi)  :: NumChans_MD = 0      !< Number of output channels from MD [-]
    INTEGER(IntKi)  :: NumChans_ADI = 0      !< Number of output channels from ADI [-]
    INTEGER(IntKi)  :: NumChans_all = 0      !< Total number of channels (sum of above) [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_SS      !< output file header names from SS [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_SS      !< output file header units from SS [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_MD      !< output file header names from MD [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_MD      !< output file header units from MD [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_ADI      !< output file header names from ADI [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_ADI      !< output file header units from ADI [-]
    REAL(c_float) , DIMENSION(:), ALLOCATABLE  :: OutData_SS_c      !< output data from SS as passed c_float [-]
    REAL(c_float) , DIMENSION(:), ALLOCATABLE  :: OutData_MD_c      !< output data from MD as passed c_float [-]
    REAL(c_float) , DIMENSION(:), ALLOCATABLE  :: OutData_ADI_c      !< output data from ADI as passed c_float [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_SS      !< output data from SS [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_MD      !< output data from MD [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_ADI      !< output data from ADI [-]
    character(1024)  :: OutName      !< Output file name [-]
    INTEGER(IntKi)  :: OutUn = -1      !< Output unit [-]
  END TYPE WrOutputDataType
! =======================
! =========  MeshesMotionType  =======
  TYPE, PUBLIC :: MeshesMotionType
    TYPE(MeshType)  :: PtfmPtMotion      !< Platform principle ref point. Also serves as tower base [-]
    TYPE(MeshType)  :: TowerMotion      !< Tower mesh (used only for vis) [-]
    TYPE(MeshType)  :: HubMotion      !< Hub mesh (for mappings, no loadings) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootMotion      !< Blade root motions [-]
    TYPE(MeshType)  :: WaveBuoyMotion      !< wave measurement buoy motion (sensor only) [-]
  END TYPE MeshesMotionType
! =======================
! =========  MeshesLoadsType  =======
  TYPE, PUBLIC :: MeshesLoadsType
    TYPE(MeshType)  :: PtfmPtLoads      !< Platform principle ref point loads output [-]
    TYPE(MeshType)  :: TowerLoads      !< Tower mesh (unused) [-]
    TYPE(MeshType)  :: HubLoads      !< Hub mesh (for mappings, intermediate loads) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootLoads      !< Blade root loads [-]
  END TYPE MeshesLoadsType
! =======================
! =========  MeshesMapsType  =======
  TYPE, PUBLIC :: MeshesMapsType
    TYPE(MeshMapType)  :: Motion_PRP_2_Twr      !< PRP to tower motion [-]
    TYPE(MeshMapType)  :: Motion_PRP_2_Hub      !< Twrtop to nacelle - add rotation afterwards [-]
    TYPE(MeshMapType)  :: Motion_Hub_2_BldRoot      !< Hub to blade root motion transfer [-]
    TYPE(MeshMapType)  :: Load_BldRoot_2_Hub      !< Blade root loads to hub [-]
    TYPE(MeshMapType)  :: Load_Hub_2_PRP      !< Hub to nacelle load transfer [-]
    TYPE(MeshMapType)  :: Load_Twr_2_PRP      !< Tower loads to PRP (unused) [-]
  END TYPE MeshesMapsType
! =======================
! =========  StructTmpType  =======
  TYPE, PUBLIC :: StructTmpType
    REAL(ReKi)  :: Azimuth = 0      !< Current Azimuth [(rad)]
    REAL(ReKi)  :: RotSpeed = 0.0_ReKi      !< Rotor speed [(RPM)]
    REAL(ReKi)  :: BldPitch = 0.0_ReKi      !< Blade pitch [(rad)]
    REAL(ReKi)  :: NacYaw = 0.0_ReKi      !< Nacelle-yaw angle [(rad)]
  END TYPE StructTmpType
! =======================
CONTAINS

subroutine WT_CopySimType(SrcSimTypeData, DstSimTypeData, CtrlCode, ErrStat, ErrMsg)
   type(SimType), intent(in) :: SrcSimTypeData
   type(SimType), intent(inout) :: DstSimTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopySimType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstSimTypeData%DT = SrcSimTypeData%DT
   DstSimTypeData%TMax = SrcSimTypeData%TMax
   DstSimTypeData%MHK = SrcSimTypeData%MHK
   DstSimTypeData%InterpOrd = SrcSimTypeData%InterpOrd
   DstSimTypeData%ScaleFact = SrcSimTypeData%ScaleFact
   DstSimTypeData%DensFact = SrcSimTypeData%DensFact
   DstSimTypeData%DebugLevel = SrcSimTypeData%DebugLevel
   DstSimTypeData%OutRootName = SrcSimTypeData%OutRootName
end subroutine

subroutine WT_DestroySimType(SimTypeData, ErrStat, ErrMsg)
   type(SimType), intent(inout) :: SimTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroySimType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackSimType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SimType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSimType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%TMax)
   call RegPack(RF, InData%MHK)
   call RegPack(RF, InData%InterpOrd)
   call RegPack(RF, InData%ScaleFact)
   call RegPack(RF, InData%DensFact)
   call RegPack(RF, InData%DebugLevel)
   call RegPack(RF, InData%OutRootName)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSimType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SimType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSimType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TMax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ScaleFact); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DensFact); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DebugLevel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutRootName); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyEnvType(SrcEnvTypeData, DstEnvTypeData, CtrlCode, ErrStat, ErrMsg)
   type(EnvType), intent(in) :: SrcEnvTypeData
   type(EnvType), intent(inout) :: DstEnvTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyEnvType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstEnvTypeData%Gravity = SrcEnvTypeData%Gravity
   DstEnvTypeData%WtrDens = SrcEnvTypeData%WtrDens
   DstEnvTypeData%WtrVisc = SrcEnvTypeData%WtrVisc
   DstEnvTypeData%SpdSound = SrcEnvTypeData%SpdSound
   DstEnvTypeData%Patm = SrcEnvTypeData%Patm
   DstEnvTypeData%Pvap = SrcEnvTypeData%Pvap
   DstEnvTypeData%WtrDpth = SrcEnvTypeData%WtrDpth
   DstEnvTypeData%MSL2SWL = SrcEnvTypeData%MSL2SWL
end subroutine

subroutine WT_DestroyEnvType(EnvTypeData, ErrStat, ErrMsg)
   type(EnvType), intent(inout) :: EnvTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyEnvType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackEnvType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(EnvType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackEnvType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%WtrDens)
   call RegPack(RF, InData%WtrVisc)
   call RegPack(RF, InData%SpdSound)
   call RegPack(RF, InData%Patm)
   call RegPack(RF, InData%Pvap)
   call RegPack(RF, InData%WtrDpth)
   call RegPack(RF, InData%MSL2SWL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackEnvType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(EnvType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackEnvType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SpdSound); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Patm); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pvap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MSL2SWL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbConfigType(SrcTurbConfigTypeData, DstTurbConfigTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TurbConfigType), intent(in) :: SrcTurbConfigTypeData
   type(TurbConfigType), intent(inout) :: DstTurbConfigTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbConfigType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbConfigTypeData%NumBl = SrcTurbConfigTypeData%NumBl
   DstTurbConfigTypeData%HubRad = SrcTurbConfigTypeData%HubRad
   DstTurbConfigTypeData%PreCone = SrcTurbConfigTypeData%PreCone
   DstTurbConfigTypeData%OverHang = SrcTurbConfigTypeData%OverHang
   DstTurbConfigTypeData%ShftTilt = SrcTurbConfigTypeData%ShftTilt
   DstTurbConfigTypeData%Twr2Shft = SrcTurbConfigTypeData%Twr2Shft
   DstTurbConfigTypeData%TowerHt = SrcTurbConfigTypeData%TowerHt
   DstTurbConfigTypeData%TowerBsPt = SrcTurbConfigTypeData%TowerBsPt
   DstTurbConfigTypeData%PtfmRefPos = SrcTurbConfigTypeData%PtfmRefPos
   DstTurbConfigTypeData%PtfmRefOrient = SrcTurbConfigTypeData%PtfmRefOrient
end subroutine

subroutine WT_DestroyTurbConfigType(TurbConfigTypeData, ErrStat, ErrMsg)
   type(TurbConfigType), intent(inout) :: TurbConfigTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbConfigType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbConfigType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbConfigType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbConfigType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumBl)
   call RegPack(RF, InData%HubRad)
   call RegPack(RF, InData%PreCone)
   call RegPack(RF, InData%OverHang)
   call RegPack(RF, InData%ShftTilt)
   call RegPack(RF, InData%Twr2Shft)
   call RegPack(RF, InData%TowerHt)
   call RegPack(RF, InData%TowerBsPt)
   call RegPack(RF, InData%PtfmRefPos)
   call RegPack(RF, InData%PtfmRefOrient)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbConfigType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbConfigType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbConfigType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumBl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PreCone); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OverHang); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShftTilt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Twr2Shft); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerHt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerBsPt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmRefPos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmRefOrient); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbInitCondType(SrcTurbInitCondTypeData, DstTurbInitCondTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TurbInitCondType), intent(in) :: SrcTurbInitCondTypeData
   type(TurbInitCondType), intent(inout) :: DstTurbInitCondTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbInitCondType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbInitCondTypeData%RotSpeed = SrcTurbInitCondTypeData%RotSpeed
   DstTurbInitCondTypeData%NacYaw = SrcTurbInitCondTypeData%NacYaw
   DstTurbInitCondTypeData%BldPitch = SrcTurbInitCondTypeData%BldPitch
   DstTurbInitCondTypeData%Azimuth = SrcTurbInitCondTypeData%Azimuth
end subroutine

subroutine WT_DestroyTurbInitCondType(TurbInitCondTypeData, ErrStat, ErrMsg)
   type(TurbInitCondType), intent(inout) :: TurbInitCondTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbInitCondType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbInitCondType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbInitCondType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbInitCondType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%NacYaw)
   call RegPack(RF, InData%BldPitch)
   call RegPack(RF, InData%Azimuth)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbInitCondType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbInitCondType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbInitCondType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NacYaw); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BldPitch); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Azimuth); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyWaveBuoyType(SrcWaveBuoyTypeData, DstWaveBuoyTypeData, CtrlCode, ErrStat, ErrMsg)
   type(WaveBuoyType), intent(in) :: SrcWaveBuoyTypeData
   type(WaveBuoyType), intent(inout) :: DstWaveBuoyTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyWaveBuoyType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWaveBuoyTypeData%XYLoc = SrcWaveBuoyTypeData%XYLoc
end subroutine

subroutine WT_DestroyWaveBuoyType(WaveBuoyTypeData, ErrStat, ErrMsg)
   type(WaveBuoyType), intent(inout) :: WaveBuoyTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyWaveBuoyType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackWaveBuoyType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(WaveBuoyType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackWaveBuoyType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%XYLoc)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackWaveBuoyType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(WaveBuoyType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackWaveBuoyType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%XYLoc); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyOutFilesType(SrcOutFilesTypeData, DstOutFilesTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutFilesType), intent(in) :: SrcOutFilesTypeData
   type(OutFilesType), intent(inout) :: DstOutFilesTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyOutFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutFilesTypeData%SendScreenToFile = SrcOutFilesTypeData%SendScreenToFile
   DstOutFilesTypeData%OutFile = SrcOutFilesTypeData%OutFile
   DstOutFilesTypeData%OutFmt = SrcOutFilesTypeData%OutFmt
end subroutine

subroutine WT_DestroyOutFilesType(OutFilesTypeData, ErrStat, ErrMsg)
   type(OutFilesType), intent(inout) :: OutFilesTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyOutFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackOutFilesType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OutFilesType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackOutFilesType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SendScreenToFile)
   call RegPack(RF, InData%OutFile)
   call RegPack(RF, InData%OutFmt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackOutFilesType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OutFilesType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackOutFilesType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SendScreenToFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFmt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyVizType(SrcVizTypeData, DstVizTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VizType), intent(in) :: SrcVizTypeData
   type(VizType), intent(inout) :: DstVizTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyVizType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVizTypeData%WrVTK = SrcVizTypeData%WrVTK
   DstVizTypeData%WrVTK_type = SrcVizTypeData%WrVTK_type
   DstVizTypeData%WrVTK_DT = SrcVizTypeData%WrVTK_DT
   DstVizTypeData%WrVTK_dir = SrcVizTypeData%WrVTK_dir
   DstVizTypeData%VTKNacDim = SrcVizTypeData%VTKNacDim
   DstVizTypeData%Twidth = SrcVizTypeData%Twidth
end subroutine

subroutine WT_DestroyVizType(VizTypeData, ErrStat, ErrMsg)
   type(VizType), intent(inout) :: VizTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyVizType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackVizType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VizType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackVizType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%WrVTK)
   call RegPack(RF, InData%WrVTK_type)
   call RegPack(RF, InData%WrVTK_DT)
   call RegPack(RF, InData%WrVTK_dir)
   call RegPack(RF, InData%VTKNacDim)
   call RegPack(RF, InData%Twidth)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackVizType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VizType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackVizType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%WrVTK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_dir); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKNacDim); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Twidth); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyModSettings(SrcModSettingsData, DstModSettingsData, CtrlCode, ErrStat, ErrMsg)
   type(ModSettings), intent(in) :: SrcModSettingsData
   type(ModSettings), intent(inout) :: DstModSettingsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyModSettings'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModSettingsData%SS_InputFile = SrcModSettingsData%SS_InputFile
   DstModSettingsData%WaveTimeShift = SrcModSettingsData%WaveTimeShift
   DstModSettingsData%MD_InputFile = SrcModSettingsData%MD_InputFile
   DstModSettingsData%AD_InputFile = SrcModSettingsData%AD_InputFile
   DstModSettingsData%IfW_InputFile = SrcModSettingsData%IfW_InputFile
end subroutine

subroutine WT_DestroyModSettings(ModSettingsData, ErrStat, ErrMsg)
   type(ModSettings), intent(inout) :: ModSettingsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyModSettings'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackModSettings(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModSettings), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackModSettings'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SS_InputFile)
   call RegPack(RF, InData%WaveTimeShift)
   call RegPack(RF, InData%MD_InputFile)
   call RegPack(RF, InData%AD_InputFile)
   call RegPack(RF, InData%IfW_InputFile)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackModSettings(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModSettings), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackModSettings'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SS_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveTimeShift); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MD_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AD_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IfW_InputFile); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopySimSettingsType(SrcSimSettingsTypeData, DstSimSettingsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(SimSettingsType), intent(in) :: SrcSimSettingsTypeData
   type(SimSettingsType), intent(inout) :: DstSimSettingsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_CopySimType(SrcSimSettingsTypeData%Sim, DstSimSettingsTypeData%Sim, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyEnvType(SrcSimSettingsTypeData%Env, DstSimSettingsTypeData%Env, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbConfigType(SrcSimSettingsTypeData%TrbCfg, DstSimSettingsTypeData%TrbCfg, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbInitCondType(SrcSimSettingsTypeData%TrbInit, DstSimSettingsTypeData%TrbInit, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyWaveBuoyType(SrcSimSettingsTypeData%WaveBuoy, DstSimSettingsTypeData%WaveBuoy, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyOutFilesType(SrcSimSettingsTypeData%Outs, DstSimSettingsTypeData%Outs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyVizType(SrcSimSettingsTypeData%Viz, DstSimSettingsTypeData%Viz, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyModSettings(SrcSimSettingsTypeData%ModSettings, DstSimSettingsTypeData%ModSettings, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroySimSettingsType(SimSettingsTypeData, ErrStat, ErrMsg)
   type(SimSettingsType), intent(inout) :: SimSettingsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_DestroySimType(SimSettingsTypeData%Sim, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyEnvType(SimSettingsTypeData%Env, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbConfigType(SimSettingsTypeData%TrbCfg, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbInitCondType(SimSettingsTypeData%TrbInit, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyWaveBuoyType(SimSettingsTypeData%WaveBuoy, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyOutFilesType(SimSettingsTypeData%Outs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyVizType(SimSettingsTypeData%Viz, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyModSettings(SimSettingsTypeData%ModSettings, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackSimSettingsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SimSettingsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSimSettingsType'
   if (RF%ErrStat >= AbortErrLev) return
   call WT_PackSimType(RF, InData%Sim) 
   call WT_PackEnvType(RF, InData%Env) 
   call WT_PackTurbConfigType(RF, InData%TrbCfg) 
   call WT_PackTurbInitCondType(RF, InData%TrbInit) 
   call WT_PackWaveBuoyType(RF, InData%WaveBuoy) 
   call WT_PackOutFilesType(RF, InData%Outs) 
   call WT_PackVizType(RF, InData%Viz) 
   call WT_PackModSettings(RF, InData%ModSettings) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSimSettingsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SimSettingsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSimSettingsType'
   if (RF%ErrStat /= ErrID_None) return
   call WT_UnpackSimType(RF, OutData%Sim) ! Sim 
   call WT_UnpackEnvType(RF, OutData%Env) ! Env 
   call WT_UnpackTurbConfigType(RF, OutData%TrbCfg) ! TrbCfg 
   call WT_UnpackTurbInitCondType(RF, OutData%TrbInit) ! TrbInit 
   call WT_UnpackWaveBuoyType(RF, OutData%WaveBuoy) ! WaveBuoy 
   call WT_UnpackOutFilesType(RF, OutData%Outs) ! Outs 
   call WT_UnpackVizType(RF, OutData%Viz) ! Viz 
   call WT_UnpackModSettings(RF, OutData%ModSettings) ! ModSettings 
end subroutine

subroutine WT_CopyCalcStepIOdataType(SrcCalcStepIOdataTypeData, DstCalcStepIOdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(CalcStepIOdataType), intent(in) :: SrcCalcStepIOdataTypeData
   type(CalcStepIOdataType), intent(inout) :: DstCalcStepIOdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyCalcStepIOdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstCalcStepIOdataTypeData%Time_c = SrcCalcStepIOdataTypeData%Time_c
   DstCalcStepIOdataTypeData%PosAng_c = SrcCalcStepIOdataTypeData%PosAng_c
   DstCalcStepIOdataTypeData%Vel_c = SrcCalcStepIOdataTypeData%Vel_c
   DstCalcStepIOdataTypeData%Acc_c = SrcCalcStepIOdataTypeData%Acc_c
   DstCalcStepIOdataTypeData%FrcMom_c = SrcCalcStepIOdataTypeData%FrcMom_c
   DstCalcStepIOdataTypeData%FrcMom_SS = SrcCalcStepIOdataTypeData%FrcMom_SS
   DstCalcStepIOdataTypeData%FrcMom_MD = SrcCalcStepIOdataTypeData%FrcMom_MD
   DstCalcStepIOdataTypeData%FrcMom_ADI = SrcCalcStepIOdataTypeData%FrcMom_ADI
   DstCalcStepIOdataTypeData%BuoyWaveElev = SrcCalcStepIOdataTypeData%BuoyWaveElev
end subroutine

subroutine WT_DestroyCalcStepIOdataType(CalcStepIOdataTypeData, ErrStat, ErrMsg)
   type(CalcStepIOdataType), intent(inout) :: CalcStepIOdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyCalcStepIOdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackCalcStepIOdataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(CalcStepIOdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackCalcStepIOdataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Time_c)
   call RegPack(RF, InData%PosAng_c)
   call RegPack(RF, InData%Vel_c)
   call RegPack(RF, InData%Acc_c)
   call RegPack(RF, InData%FrcMom_c)
   call RegPack(RF, InData%FrcMom_SS)
   call RegPack(RF, InData%FrcMom_MD)
   call RegPack(RF, InData%FrcMom_ADI)
   call RegPack(RF, InData%BuoyWaveElev)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackCalcStepIOdataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(CalcStepIOdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackCalcStepIOdataType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Time_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PosAng_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vel_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Acc_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BuoyWaveElev); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyWrOutputDataType(SrcWrOutputDataTypeData, DstWrOutputDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(WrOutputDataType), intent(in) :: SrcWrOutputDataTypeData
   type(WrOutputDataType), intent(inout) :: DstWrOutputDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'WT_CopyWrOutputDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWrOutputDataTypeData%NumChans_cbind = SrcWrOutputDataTypeData%NumChans_cbind
   DstWrOutputDataTypeData%NumChans_SS = SrcWrOutputDataTypeData%NumChans_SS
   DstWrOutputDataTypeData%NumChans_MD = SrcWrOutputDataTypeData%NumChans_MD
   DstWrOutputDataTypeData%NumChans_ADI = SrcWrOutputDataTypeData%NumChans_ADI
   DstWrOutputDataTypeData%NumChans_all = SrcWrOutputDataTypeData%NumChans_all
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_SS)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_SS)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_SS = SrcWrOutputDataTypeData%WriteOutputHdr_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_SS)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_SS)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_SS = SrcWrOutputDataTypeData%WriteOutputUnt_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_MD)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_MD)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_MD = SrcWrOutputDataTypeData%WriteOutputHdr_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_MD)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_MD)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_MD = SrcWrOutputDataTypeData%WriteOutputUnt_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_ADI)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_ADI = SrcWrOutputDataTypeData%WriteOutputHdr_ADI
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_ADI)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_ADI = SrcWrOutputDataTypeData%WriteOutputUnt_ADI
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_SS_c)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_SS_c)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_SS_c)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_SS_c)) then
         allocate(DstWrOutputDataTypeData%OutData_SS_c(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_SS_c.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_SS_c = SrcWrOutputDataTypeData%OutData_SS_c
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_MD_c)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_MD_c)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_MD_c)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_MD_c)) then
         allocate(DstWrOutputDataTypeData%OutData_MD_c(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_MD_c.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_MD_c = SrcWrOutputDataTypeData%OutData_MD_c
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_ADI_c)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_ADI_c)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_ADI_c)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_ADI_c)) then
         allocate(DstWrOutputDataTypeData%OutData_ADI_c(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_ADI_c.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_ADI_c = SrcWrOutputDataTypeData%OutData_ADI_c
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_SS)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_SS)) then
         allocate(DstWrOutputDataTypeData%OutData_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_SS = SrcWrOutputDataTypeData%OutData_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_MD)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_MD)) then
         allocate(DstWrOutputDataTypeData%OutData_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_MD = SrcWrOutputDataTypeData%OutData_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_ADI)) then
         allocate(DstWrOutputDataTypeData%OutData_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_ADI = SrcWrOutputDataTypeData%OutData_ADI
   end if
   DstWrOutputDataTypeData%OutName = SrcWrOutputDataTypeData%OutName
   DstWrOutputDataTypeData%OutUn = SrcWrOutputDataTypeData%OutUn
end subroutine

subroutine WT_DestroyWrOutputDataType(WrOutputDataTypeData, ErrStat, ErrMsg)
   type(WrOutputDataType), intent(inout) :: WrOutputDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyWrOutputDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_SS)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_SS)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_SS)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_SS)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_MD)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_MD)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_MD)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_MD)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_ADI)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_ADI)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_ADI)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_ADI)
   end if
   if (allocated(WrOutputDataTypeData%OutData_SS_c)) then
      deallocate(WrOutputDataTypeData%OutData_SS_c)
   end if
   if (allocated(WrOutputDataTypeData%OutData_MD_c)) then
      deallocate(WrOutputDataTypeData%OutData_MD_c)
   end if
   if (allocated(WrOutputDataTypeData%OutData_ADI_c)) then
      deallocate(WrOutputDataTypeData%OutData_ADI_c)
   end if
   if (allocated(WrOutputDataTypeData%OutData_SS)) then
      deallocate(WrOutputDataTypeData%OutData_SS)
   end if
   if (allocated(WrOutputDataTypeData%OutData_MD)) then
      deallocate(WrOutputDataTypeData%OutData_MD)
   end if
   if (allocated(WrOutputDataTypeData%OutData_ADI)) then
      deallocate(WrOutputDataTypeData%OutData_ADI)
   end if
end subroutine

subroutine WT_PackWrOutputDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(WrOutputDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackWrOutputDataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumChans_cbind)
   call RegPack(RF, InData%NumChans_SS)
   call RegPack(RF, InData%NumChans_MD)
   call RegPack(RF, InData%NumChans_ADI)
   call RegPack(RF, InData%NumChans_all)
   call RegPackAlloc(RF, InData%WriteOutputHdr_SS)
   call RegPackAlloc(RF, InData%WriteOutputUnt_SS)
   call RegPackAlloc(RF, InData%WriteOutputHdr_MD)
   call RegPackAlloc(RF, InData%WriteOutputUnt_MD)
   call RegPackAlloc(RF, InData%WriteOutputHdr_ADI)
   call RegPackAlloc(RF, InData%WriteOutputUnt_ADI)
   call RegPackAlloc(RF, InData%OutData_SS_c)
   call RegPackAlloc(RF, InData%OutData_MD_c)
   call RegPackAlloc(RF, InData%OutData_ADI_c)
   call RegPackAlloc(RF, InData%OutData_SS)
   call RegPackAlloc(RF, InData%OutData_MD)
   call RegPackAlloc(RF, InData%OutData_ADI)
   call RegPack(RF, InData%OutName)
   call RegPack(RF, InData%OutUn)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackWrOutputDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(WrOutputDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackWrOutputDataType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumChans_cbind); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_all); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_SS_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_MD_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_ADI_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutUn); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyMeshesMotionType(SrcMeshesMotionTypeData, DstMeshesMotionTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesMotionType), intent(inout) :: SrcMeshesMotionTypeData
   type(MeshesMotionType), intent(inout) :: DstMeshesMotionTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesMotionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMeshesMotionTypeData%PtfmPtMotion, DstMeshesMotionTypeData%PtfmPtMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionTypeData%TowerMotion, DstMeshesMotionTypeData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionTypeData%HubMotion, DstMeshesMotionTypeData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMeshesMotionTypeData%BladeRootMotion)) then
      LB(1:1) = lbound(SrcMeshesMotionTypeData%BladeRootMotion)
      UB(1:1) = ubound(SrcMeshesMotionTypeData%BladeRootMotion)
      if (.not. allocated(DstMeshesMotionTypeData%BladeRootMotion)) then
         allocate(DstMeshesMotionTypeData%BladeRootMotion(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshesMotionTypeData%BladeRootMotion.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshesMotionTypeData%BladeRootMotion(i1), DstMeshesMotionTypeData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcMeshesMotionTypeData%WaveBuoyMotion, DstMeshesMotionTypeData%WaveBuoyMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroyMeshesMotionType(MeshesMotionTypeData, ErrStat, ErrMsg)
   type(MeshesMotionType), intent(inout) :: MeshesMotionTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesMotionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MeshesMotionTypeData%PtfmPtMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionTypeData%TowerMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionTypeData%HubMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MeshesMotionTypeData%BladeRootMotion)) then
      LB(1:1) = lbound(MeshesMotionTypeData%BladeRootMotion)
      UB(1:1) = ubound(MeshesMotionTypeData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshesMotionTypeData%BladeRootMotion(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshesMotionTypeData%BladeRootMotion)
   end if
   call MeshDestroy( MeshesMotionTypeData%WaveBuoyMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackMeshesMotionType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesMotionType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesMotionType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPtMotion) 
   call MeshPack(RF, InData%TowerMotion) 
   call MeshPack(RF, InData%HubMotion) 
   call RegPack(RF, allocated(InData%BladeRootMotion))
   if (allocated(InData%BladeRootMotion)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootMotion), ubound(InData%BladeRootMotion))
      LB(1:1) = lbound(InData%BladeRootMotion)
      UB(1:1) = ubound(InData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootMotion(i1)) 
      end do
   end if
   call MeshPack(RF, InData%WaveBuoyMotion) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesMotionType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesMotionType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesMotionType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPtMotion) ! PtfmPtMotion 
   call MeshUnpack(RF, OutData%TowerMotion) ! TowerMotion 
   call MeshUnpack(RF, OutData%HubMotion) ! HubMotion 
   if (allocated(OutData%BladeRootMotion)) deallocate(OutData%BladeRootMotion)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootMotion(i1)) ! BladeRootMotion 
      end do
   end if
   call MeshUnpack(RF, OutData%WaveBuoyMotion) ! WaveBuoyMotion 
end subroutine

subroutine WT_CopyMeshesLoadsType(SrcMeshesLoadsTypeData, DstMeshesLoadsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesLoadsType), intent(inout) :: SrcMeshesLoadsTypeData
   type(MeshesLoadsType), intent(inout) :: DstMeshesLoadsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesLoadsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMeshesLoadsTypeData%PtfmPtLoads, DstMeshesLoadsTypeData%PtfmPtLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesLoadsTypeData%TowerLoads, DstMeshesLoadsTypeData%TowerLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesLoadsTypeData%HubLoads, DstMeshesLoadsTypeData%HubLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMeshesLoadsTypeData%BladeRootLoads)) then
      LB(1:1) = lbound(SrcMeshesLoadsTypeData%BladeRootLoads)
      UB(1:1) = ubound(SrcMeshesLoadsTypeData%BladeRootLoads)
      if (.not. allocated(DstMeshesLoadsTypeData%BladeRootLoads)) then
         allocate(DstMeshesLoadsTypeData%BladeRootLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshesLoadsTypeData%BladeRootLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshesLoadsTypeData%BladeRootLoads(i1), DstMeshesLoadsTypeData%BladeRootLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine WT_DestroyMeshesLoadsType(MeshesLoadsTypeData, ErrStat, ErrMsg)
   type(MeshesLoadsType), intent(inout) :: MeshesLoadsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesLoadsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MeshesLoadsTypeData%PtfmPtLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesLoadsTypeData%TowerLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesLoadsTypeData%HubLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MeshesLoadsTypeData%BladeRootLoads)) then
      LB(1:1) = lbound(MeshesLoadsTypeData%BladeRootLoads)
      UB(1:1) = ubound(MeshesLoadsTypeData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshesLoadsTypeData%BladeRootLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshesLoadsTypeData%BladeRootLoads)
   end if
end subroutine

subroutine WT_PackMeshesLoadsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesLoadsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesLoadsType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPtLoads) 
   call MeshPack(RF, InData%TowerLoads) 
   call MeshPack(RF, InData%HubLoads) 
   call RegPack(RF, allocated(InData%BladeRootLoads))
   if (allocated(InData%BladeRootLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootLoads), ubound(InData%BladeRootLoads))
      LB(1:1) = lbound(InData%BladeRootLoads)
      UB(1:1) = ubound(InData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootLoads(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesLoadsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesLoadsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesLoadsType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPtLoads) ! PtfmPtLoads 
   call MeshUnpack(RF, OutData%TowerLoads) ! TowerLoads 
   call MeshUnpack(RF, OutData%HubLoads) ! HubLoads 
   if (allocated(OutData%BladeRootLoads)) deallocate(OutData%BladeRootLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootLoads(i1)) ! BladeRootLoads 
      end do
   end if
end subroutine

subroutine WT_CopyMeshesMapsType(SrcMeshesMapsTypeData, DstMeshesMapsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesMapsType), intent(inout) :: SrcMeshesMapsTypeData
   type(MeshesMapsType), intent(inout) :: DstMeshesMapsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesMapsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Motion_PRP_2_Twr, DstMeshesMapsTypeData%Motion_PRP_2_Twr, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Motion_PRP_2_Hub, DstMeshesMapsTypeData%Motion_PRP_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Motion_Hub_2_BldRoot, DstMeshesMapsTypeData%Motion_Hub_2_BldRoot, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Load_BldRoot_2_Hub, DstMeshesMapsTypeData%Load_BldRoot_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Load_Hub_2_PRP, DstMeshesMapsTypeData%Load_Hub_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsTypeData%Load_Twr_2_PRP, DstMeshesMapsTypeData%Load_Twr_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroyMeshesMapsType(MeshesMapsTypeData, ErrStat, ErrMsg)
   type(MeshesMapsType), intent(inout) :: MeshesMapsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesMapsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Motion_PRP_2_Twr, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Motion_PRP_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Motion_Hub_2_BldRoot, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Load_BldRoot_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Load_Hub_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsTypeData%Load_Twr_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackMeshesMapsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesMapsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesMapsType'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Twr) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_Hub_2_BldRoot) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_BldRoot_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Hub_2_PRP) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Twr_2_PRP) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesMapsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesMapsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesMapsType'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Twr) ! Motion_PRP_2_Twr 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Hub) ! Motion_PRP_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_Hub_2_BldRoot) ! Motion_Hub_2_BldRoot 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_BldRoot_2_Hub) ! Load_BldRoot_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Hub_2_PRP) ! Load_Hub_2_PRP 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Twr_2_PRP) ! Load_Twr_2_PRP 
end subroutine

subroutine WT_CopyStructTmpType(SrcStructTmpTypeData, DstStructTmpTypeData, CtrlCode, ErrStat, ErrMsg)
   type(StructTmpType), intent(in) :: SrcStructTmpTypeData
   type(StructTmpType), intent(inout) :: DstStructTmpTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyStructTmpType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstStructTmpTypeData%Azimuth = SrcStructTmpTypeData%Azimuth
   DstStructTmpTypeData%RotSpeed = SrcStructTmpTypeData%RotSpeed
   DstStructTmpTypeData%BldPitch = SrcStructTmpTypeData%BldPitch
   DstStructTmpTypeData%NacYaw = SrcStructTmpTypeData%NacYaw
end subroutine

subroutine WT_DestroyStructTmpType(StructTmpTypeData, ErrStat, ErrMsg)
   type(StructTmpType), intent(inout) :: StructTmpTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyStructTmpType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackStructTmpType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(StructTmpType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackStructTmpType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Azimuth)
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%BldPitch)
   call RegPack(RF, InData%NacYaw)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackStructTmpType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(StructTmpType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackStructTmpType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Azimuth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BldPitch); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NacYaw); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE WaveTank_Types
!ENDOFREGISTRYGENERATEDFILE
