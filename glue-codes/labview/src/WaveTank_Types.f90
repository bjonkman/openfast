!STARTOFREGISTRYGENERATEDFILE 'WaveTank_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WaveTank_Types
!.................................................................................................................................
! This file is part of WaveTank.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WaveTank. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WaveTank_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE ISO_C_BINDING
USE NWTC_Library
IMPLICIT NONE
! =========  Sim  =======
  TYPE, PUBLIC :: Sim
    REAL(c_double)  :: DT = 0.0_R8Ki      !< timestep [-]
    REAL(c_double)  :: TMax = 0.0_R8Ki      !< Max sim time [-]
    INTEGER(c_int)  :: MHK = 0_IntKi      !< MHK turbine type (switch) {0=Not an MHK turbine; 1=Fixed MHK turbine; 2=Floating MHK turbine} [(-)]
    INTEGER(c_int)  :: InterpOrd = 1      !< Interpolation order [-]
    INTEGER(c_int)  :: DebugLevel = 0_IntKi      !< Debug level for outputs [-]
    character(1024)  :: OutRootName      !< Rootname for outputs [-]
  END TYPE Sim
! =======================
! =========  Env  =======
  TYPE, PUBLIC :: Env
    REAL(c_float)  :: Gravity = 0.0_R4Ki      !< gravitational constant (positive for down) [(m/s^2)]
    REAL(c_float)  :: WtrDens = 0.0_R4Ki      !< Water density [(kg/m^3)]
    REAL(c_float)  :: WtrVisc = 0.0_R4Ki      !< fluid viscosity [(m^2/s)]
    REAL(c_float)  :: SpdSound = 0.0_R4Ki      !< Speed of sound in working fluid [(m/s)]
    REAL(c_float)  :: Patm = 0.0_R4Ki      !< Atmospheric pressure  [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: Pvap = 0.0_R4Ki      !< Vapour pressure of working fluid [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: WtrDpth = 0.0_R4Ki      !< Water depth [(m)]
    REAL(c_float)  :: MSL2SWL = 0.0_R4Ki      !< Mean sea level to still water level [(m)]
  END TYPE Env
! =======================
! =========  TurbConfig  =======
  TYPE, PUBLIC :: TurbConfig
    INTEGER(c_int)  :: NumBl = 0_IntKi      !< Number of blades [(-)]
    REAL(c_float)  :: TipRad = 0.0_R4Ki      !< The distance from the rotor apex to the blade tip [(m)]
    REAL(c_float)  :: HubRad = 0.0_R4Ki      !< The distance from the rotor apex to the blade root [(m)]
    REAL(c_float)  :: PreCone = 0.0_R4Ki      !< Blade cone angle [(deg)]
    REAL(c_float)  :: OverHang = 0.0_R4Ki      !< Distance from yaw axis to rotor apex [3 blades] or teeter pin [2 blades] [(m)]
    REAL(c_float)  :: ShftGagL = 0.0_R4Ki      !< Distance from rotor apex [3 blades] or teeter pin [2 blades] to shaft strain gages [positive for upwind rotors] [(m)]
    REAL(c_float)  :: ShftTilt = 0.0_R4Ki      !< Rotor shaft tilt angle [(deg)]
    REAL(c_float)  :: Twr2Shft = 0.0_R4Ki      !< Vertical distance from the tower-top to the rotor shaft [(m)]
    REAL(c_float)  :: TowerHt = 0.0_R4Ki      !< Height of tower relative MSL [(m)]
    REAL(c_float)  :: TowerBsHt = 0.0_R4Ki      !< Height of tower base relative to ground level [onshore], MSL [floating MHK] [(m)]
    REAL(c_float) , DIMENSION(1:3)  :: PtfmRef = 0.0_R4Ki      !< Location of platform reference point, relative to MSL.  Motions and loads all connect to this point [(m)]
  END TYPE TurbConfig
! =======================
! =========  TurbOpPoint  =======
  TYPE, PUBLIC :: TurbOpPoint
    REAL(c_float)  :: RotSpeed = 0.0_R4Ki      !< Rotor speed [(RPM)]
    REAL(c_float)  :: BldPitch = 0.0_R4Ki      !< Fixed blade pitch for full simulation [(deg)]
  END TYPE TurbOpPoint
! =======================
! =========  Output  =======
  TYPE, PUBLIC :: Output
    LOGICAL  :: SendScreenToFile = .false.      !< send to file <OutRootName>.screen.log if true [(-)]
    INTEGER(c_int)  :: OutFile = 0_IntKi      !< 0: no output file of channels, 1: output file in text format (at DT) [(-)]
    character(20)  :: OutFmt      !< Format used for text tabular output, excluding the time channel. (quoted string) [(-)]
  END TYPE Output
! =======================
! =========  Viz  =======
  TYPE, PUBLIC :: Viz
    INTEGER(c_int)  :: WrVTK = 0_IntKi      !< Write VTK? [-]
    INTEGER(c_int)  :: WrVTK_type = 0_IntKi      !< Write VTK outputs as [1: surface, 2: lines, 3: both] [-]
    REAL(c_double)  :: WrVTK_DT = 0.0_R8Ki      !< Time step between VTK writes [-]
    character(1024)  :: WrVTK_dir      !< Directory for VTK writing [-]
    REAL(c_float) , DIMENSION(1:6)  :: VTKNacDim = 0.0_R4Ki      !< Nacelle dimension passed in for VTK surface rendering [0,y0,z0,Lx,Ly,Lz] [(m)]
  END TYPE Viz
! =======================
! =========  SimSettingsType  =======
  TYPE, PUBLIC :: SimSettingsType
    TYPE(Sim)  :: Sim      !< Simulation settings [-]
    TYPE(Env)  :: Env      !< Environment settings [-]
    TYPE(TurbConfig)  :: TCfg      !< Turbine configuration [-]
    TYPE(TurbOpPoint)  :: TOp      !< Turbine operating point [-]
    TYPE(Output)  :: Outs      !< Output settings [-]
    TYPE(Viz)  :: Viz      !< Vizualization settings [-]
  END TYPE SimSettingsType
! =======================
! =========  MeshesMotion  =======
  TYPE, PUBLIC :: MeshesMotion
    TYPE(MeshType)  :: PtfmPRPMotion      !< Platform principle ref point. Also serves as tower base [-]
    TYPE(MeshType)  :: TowerMotion      !< Tower mesh (used only for vis) [-]
    TYPE(MeshType)  :: HubMotion      !< Hub mesh (for mappings, no loadings) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootMotion      !< Blade root motions [-]
  END TYPE MeshesMotion
! =======================
! =========  MesheshLoads  =======
  TYPE, PUBLIC :: MesheshLoads
    TYPE(MeshType)  :: PtfmPRPLoads      !< Platform principle ref point loads output [-]
    TYPE(MeshType)  :: TowerLoads      !< Tower mesh (unused) [-]
    TYPE(MeshType)  :: HubLoads      !< Hub mesh (for mappings, intermediate loads) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootLoads      !< Blade root loads [-]
  END TYPE MesheshLoads
! =======================
! =========  MeshMaps  =======
  TYPE, PUBLIC :: MeshMaps
    TYPE(MeshMapType)  :: Motion_PRP_2_Twr      !< PRP to tower motion [-]
    TYPE(MeshMapType)  :: Motion_PRP_2_Hub      !< Twrtop to nacelle - add rotation afterwards [-]
    TYPE(MeshMapType)  :: Motion_Hub_2_BldRoot      !< Hub to blade root motion transfer [-]
    TYPE(MeshMapType)  :: Load_BldRoot_2_Hub      !< Blade root loads to hub [-]
    TYPE(MeshMapType)  :: Load_Hub_2_PRP      !< Hub to nacelle load transfer [-]
    TYPE(MeshMapType)  :: Load_Twr_2_PRP      !< Tower loads to PRP (unused) [-]
  END TYPE MeshMaps
! =======================
CONTAINS

subroutine WT_CopySim(SrcSimData, DstSimData, CtrlCode, ErrStat, ErrMsg)
   type(Sim), intent(in) :: SrcSimData
   type(Sim), intent(inout) :: DstSimData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopySim'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstSimData%DT = SrcSimData%DT
   DstSimData%TMax = SrcSimData%TMax
   DstSimData%MHK = SrcSimData%MHK
   DstSimData%InterpOrd = SrcSimData%InterpOrd
   DstSimData%DebugLevel = SrcSimData%DebugLevel
   DstSimData%OutRootName = SrcSimData%OutRootName
end subroutine

subroutine WT_DestroySim(SimData, ErrStat, ErrMsg)
   type(Sim), intent(inout) :: SimData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroySim'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackSim(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Sim), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSim'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%TMax)
   call RegPack(RF, InData%MHK)
   call RegPack(RF, InData%InterpOrd)
   call RegPack(RF, InData%DebugLevel)
   call RegPack(RF, InData%OutRootName)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSim(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Sim), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSim'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TMax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DebugLevel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutRootName); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyEnv(SrcEnvData, DstEnvData, CtrlCode, ErrStat, ErrMsg)
   type(Env), intent(in) :: SrcEnvData
   type(Env), intent(inout) :: DstEnvData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyEnv'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstEnvData%Gravity = SrcEnvData%Gravity
   DstEnvData%WtrDens = SrcEnvData%WtrDens
   DstEnvData%WtrVisc = SrcEnvData%WtrVisc
   DstEnvData%SpdSound = SrcEnvData%SpdSound
   DstEnvData%Patm = SrcEnvData%Patm
   DstEnvData%Pvap = SrcEnvData%Pvap
   DstEnvData%WtrDpth = SrcEnvData%WtrDpth
   DstEnvData%MSL2SWL = SrcEnvData%MSL2SWL
end subroutine

subroutine WT_DestroyEnv(EnvData, ErrStat, ErrMsg)
   type(Env), intent(inout) :: EnvData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyEnv'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackEnv(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Env), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackEnv'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%WtrDens)
   call RegPack(RF, InData%WtrVisc)
   call RegPack(RF, InData%SpdSound)
   call RegPack(RF, InData%Patm)
   call RegPack(RF, InData%Pvap)
   call RegPack(RF, InData%WtrDpth)
   call RegPack(RF, InData%MSL2SWL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackEnv(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Env), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackEnv'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SpdSound); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Patm); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pvap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MSL2SWL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbConfig(SrcTurbConfigData, DstTurbConfigData, CtrlCode, ErrStat, ErrMsg)
   type(TurbConfig), intent(in) :: SrcTurbConfigData
   type(TurbConfig), intent(inout) :: DstTurbConfigData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbConfigData%NumBl = SrcTurbConfigData%NumBl
   DstTurbConfigData%TipRad = SrcTurbConfigData%TipRad
   DstTurbConfigData%HubRad = SrcTurbConfigData%HubRad
   DstTurbConfigData%PreCone = SrcTurbConfigData%PreCone
   DstTurbConfigData%OverHang = SrcTurbConfigData%OverHang
   DstTurbConfigData%ShftGagL = SrcTurbConfigData%ShftGagL
   DstTurbConfigData%ShftTilt = SrcTurbConfigData%ShftTilt
   DstTurbConfigData%Twr2Shft = SrcTurbConfigData%Twr2Shft
   DstTurbConfigData%TowerHt = SrcTurbConfigData%TowerHt
   DstTurbConfigData%TowerBsHt = SrcTurbConfigData%TowerBsHt
   DstTurbConfigData%PtfmRef = SrcTurbConfigData%PtfmRef
end subroutine

subroutine WT_DestroyTurbConfig(TurbConfigData, ErrStat, ErrMsg)
   type(TurbConfig), intent(inout) :: TurbConfigData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbConfig(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbConfig), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbConfig'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumBl)
   call RegPack(RF, InData%TipRad)
   call RegPack(RF, InData%HubRad)
   call RegPack(RF, InData%PreCone)
   call RegPack(RF, InData%OverHang)
   call RegPack(RF, InData%ShftGagL)
   call RegPack(RF, InData%ShftTilt)
   call RegPack(RF, InData%Twr2Shft)
   call RegPack(RF, InData%TowerHt)
   call RegPack(RF, InData%TowerBsHt)
   call RegPack(RF, InData%PtfmRef)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbConfig(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbConfig), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbConfig'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumBl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TipRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PreCone); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OverHang); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShftGagL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShftTilt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Twr2Shft); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerHt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerBsHt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmRef); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbOpPoint(SrcTurbOpPointData, DstTurbOpPointData, CtrlCode, ErrStat, ErrMsg)
   type(TurbOpPoint), intent(in) :: SrcTurbOpPointData
   type(TurbOpPoint), intent(inout) :: DstTurbOpPointData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbOpPoint'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbOpPointData%RotSpeed = SrcTurbOpPointData%RotSpeed
   DstTurbOpPointData%BldPitch = SrcTurbOpPointData%BldPitch
end subroutine

subroutine WT_DestroyTurbOpPoint(TurbOpPointData, ErrStat, ErrMsg)
   type(TurbOpPoint), intent(inout) :: TurbOpPointData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbOpPoint'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbOpPoint(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbOpPoint), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbOpPoint'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%BldPitch)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbOpPoint(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbOpPoint), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbOpPoint'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BldPitch); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Output), intent(in) :: SrcOutputData
   type(Output), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutputData%SendScreenToFile = SrcOutputData%SendScreenToFile
   DstOutputData%OutFile = SrcOutputData%OutFile
   DstOutputData%OutFmt = SrcOutputData%OutFmt
end subroutine

subroutine WT_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(Output), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Output), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SendScreenToFile)
   call RegPack(RF, InData%OutFile)
   call RegPack(RF, InData%OutFmt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Output), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackOutput'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SendScreenToFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFmt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyViz(SrcVizData, DstVizData, CtrlCode, ErrStat, ErrMsg)
   type(Viz), intent(in) :: SrcVizData
   type(Viz), intent(inout) :: DstVizData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyViz'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVizData%WrVTK = SrcVizData%WrVTK
   DstVizData%WrVTK_type = SrcVizData%WrVTK_type
   DstVizData%WrVTK_DT = SrcVizData%WrVTK_DT
   DstVizData%WrVTK_dir = SrcVizData%WrVTK_dir
   DstVizData%VTKNacDim = SrcVizData%VTKNacDim
end subroutine

subroutine WT_DestroyViz(VizData, ErrStat, ErrMsg)
   type(Viz), intent(inout) :: VizData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyViz'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackViz(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Viz), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackViz'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%WrVTK)
   call RegPack(RF, InData%WrVTK_type)
   call RegPack(RF, InData%WrVTK_DT)
   call RegPack(RF, InData%WrVTK_dir)
   call RegPack(RF, InData%VTKNacDim)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackViz(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Viz), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackViz'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%WrVTK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_dir); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKNacDim); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopySimSettingsType(SrcSimSettingsTypeData, DstSimSettingsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(SimSettingsType), intent(in) :: SrcSimSettingsTypeData
   type(SimSettingsType), intent(inout) :: DstSimSettingsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_CopySim(SrcSimSettingsTypeData%Sim, DstSimSettingsTypeData%Sim, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyEnv(SrcSimSettingsTypeData%Env, DstSimSettingsTypeData%Env, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbConfig(SrcSimSettingsTypeData%TCfg, DstSimSettingsTypeData%TCfg, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbOpPoint(SrcSimSettingsTypeData%TOp, DstSimSettingsTypeData%TOp, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyOutput(SrcSimSettingsTypeData%Outs, DstSimSettingsTypeData%Outs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyViz(SrcSimSettingsTypeData%Viz, DstSimSettingsTypeData%Viz, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroySimSettingsType(SimSettingsTypeData, ErrStat, ErrMsg)
   type(SimSettingsType), intent(inout) :: SimSettingsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_DestroySim(SimSettingsTypeData%Sim, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyEnv(SimSettingsTypeData%Env, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbConfig(SimSettingsTypeData%TCfg, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbOpPoint(SimSettingsTypeData%TOp, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyOutput(SimSettingsTypeData%Outs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyViz(SimSettingsTypeData%Viz, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackSimSettingsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SimSettingsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSimSettingsType'
   if (RF%ErrStat >= AbortErrLev) return
   call WT_PackSim(RF, InData%Sim) 
   call WT_PackEnv(RF, InData%Env) 
   call WT_PackTurbConfig(RF, InData%TCfg) 
   call WT_PackTurbOpPoint(RF, InData%TOp) 
   call WT_PackOutput(RF, InData%Outs) 
   call WT_PackViz(RF, InData%Viz) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSimSettingsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SimSettingsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSimSettingsType'
   if (RF%ErrStat /= ErrID_None) return
   call WT_UnpackSim(RF, OutData%Sim) ! Sim 
   call WT_UnpackEnv(RF, OutData%Env) ! Env 
   call WT_UnpackTurbConfig(RF, OutData%TCfg) ! TCfg 
   call WT_UnpackTurbOpPoint(RF, OutData%TOp) ! TOp 
   call WT_UnpackOutput(RF, OutData%Outs) ! Outs 
   call WT_UnpackViz(RF, OutData%Viz) ! Viz 
end subroutine

subroutine WT_CopyMeshesMotion(SrcMeshesMotionData, DstMeshesMotionData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesMotion), intent(inout) :: SrcMeshesMotionData
   type(MeshesMotion), intent(inout) :: DstMeshesMotionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesMotion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMeshesMotionData%PtfmPRPMotion, DstMeshesMotionData%PtfmPRPMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionData%TowerMotion, DstMeshesMotionData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionData%HubMotion, DstMeshesMotionData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMeshesMotionData%BladeRootMotion)) then
      LB(1:1) = lbound(SrcMeshesMotionData%BladeRootMotion)
      UB(1:1) = ubound(SrcMeshesMotionData%BladeRootMotion)
      if (.not. allocated(DstMeshesMotionData%BladeRootMotion)) then
         allocate(DstMeshesMotionData%BladeRootMotion(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshesMotionData%BladeRootMotion.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshesMotionData%BladeRootMotion(i1), DstMeshesMotionData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine WT_DestroyMeshesMotion(MeshesMotionData, ErrStat, ErrMsg)
   type(MeshesMotion), intent(inout) :: MeshesMotionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesMotion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MeshesMotionData%PtfmPRPMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionData%TowerMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionData%HubMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MeshesMotionData%BladeRootMotion)) then
      LB(1:1) = lbound(MeshesMotionData%BladeRootMotion)
      UB(1:1) = ubound(MeshesMotionData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshesMotionData%BladeRootMotion(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshesMotionData%BladeRootMotion)
   end if
end subroutine

subroutine WT_PackMeshesMotion(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesMotion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesMotion'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPRPMotion) 
   call MeshPack(RF, InData%TowerMotion) 
   call MeshPack(RF, InData%HubMotion) 
   call RegPack(RF, allocated(InData%BladeRootMotion))
   if (allocated(InData%BladeRootMotion)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootMotion), ubound(InData%BladeRootMotion))
      LB(1:1) = lbound(InData%BladeRootMotion)
      UB(1:1) = ubound(InData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootMotion(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesMotion(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesMotion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesMotion'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPRPMotion) ! PtfmPRPMotion 
   call MeshUnpack(RF, OutData%TowerMotion) ! TowerMotion 
   call MeshUnpack(RF, OutData%HubMotion) ! HubMotion 
   if (allocated(OutData%BladeRootMotion)) deallocate(OutData%BladeRootMotion)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootMotion(i1)) ! BladeRootMotion 
      end do
   end if
end subroutine

subroutine WT_CopyMesheshLoads(SrcMesheshLoadsData, DstMesheshLoadsData, CtrlCode, ErrStat, ErrMsg)
   type(MesheshLoads), intent(inout) :: SrcMesheshLoadsData
   type(MesheshLoads), intent(inout) :: DstMesheshLoadsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMesheshLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMesheshLoadsData%PtfmPRPLoads, DstMesheshLoadsData%PtfmPRPLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMesheshLoadsData%TowerLoads, DstMesheshLoadsData%TowerLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMesheshLoadsData%HubLoads, DstMesheshLoadsData%HubLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMesheshLoadsData%BladeRootLoads)) then
      LB(1:1) = lbound(SrcMesheshLoadsData%BladeRootLoads)
      UB(1:1) = ubound(SrcMesheshLoadsData%BladeRootLoads)
      if (.not. allocated(DstMesheshLoadsData%BladeRootLoads)) then
         allocate(DstMesheshLoadsData%BladeRootLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMesheshLoadsData%BladeRootLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMesheshLoadsData%BladeRootLoads(i1), DstMesheshLoadsData%BladeRootLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine WT_DestroyMesheshLoads(MesheshLoadsData, ErrStat, ErrMsg)
   type(MesheshLoads), intent(inout) :: MesheshLoadsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMesheshLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MesheshLoadsData%PtfmPRPLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MesheshLoadsData%TowerLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MesheshLoadsData%HubLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MesheshLoadsData%BladeRootLoads)) then
      LB(1:1) = lbound(MesheshLoadsData%BladeRootLoads)
      UB(1:1) = ubound(MesheshLoadsData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MesheshLoadsData%BladeRootLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MesheshLoadsData%BladeRootLoads)
   end if
end subroutine

subroutine WT_PackMesheshLoads(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MesheshLoads), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMesheshLoads'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPRPLoads) 
   call MeshPack(RF, InData%TowerLoads) 
   call MeshPack(RF, InData%HubLoads) 
   call RegPack(RF, allocated(InData%BladeRootLoads))
   if (allocated(InData%BladeRootLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootLoads), ubound(InData%BladeRootLoads))
      LB(1:1) = lbound(InData%BladeRootLoads)
      UB(1:1) = ubound(InData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootLoads(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMesheshLoads(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MesheshLoads), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMesheshLoads'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPRPLoads) ! PtfmPRPLoads 
   call MeshUnpack(RF, OutData%TowerLoads) ! TowerLoads 
   call MeshUnpack(RF, OutData%HubLoads) ! HubLoads 
   if (allocated(OutData%BladeRootLoads)) deallocate(OutData%BladeRootLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootLoads(i1)) ! BladeRootLoads 
      end do
   end if
end subroutine

subroutine WT_CopyMeshMaps(SrcMeshMapsData, DstMeshMapsData, CtrlCode, ErrStat, ErrMsg)
   type(MeshMaps), intent(inout) :: SrcMeshMapsData
   type(MeshMaps), intent(inout) :: DstMeshMapsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshMaps'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Motion_PRP_2_Twr, DstMeshMapsData%Motion_PRP_2_Twr, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Motion_PRP_2_Hub, DstMeshMapsData%Motion_PRP_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Motion_Hub_2_BldRoot, DstMeshMapsData%Motion_Hub_2_BldRoot, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Load_BldRoot_2_Hub, DstMeshMapsData%Load_BldRoot_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Load_Hub_2_PRP, DstMeshMapsData%Load_Hub_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshMapsData%Load_Twr_2_PRP, DstMeshMapsData%Load_Twr_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroyMeshMaps(MeshMapsData, ErrStat, ErrMsg)
   type(MeshMaps), intent(inout) :: MeshMapsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshMaps'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Motion_PRP_2_Twr, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Motion_PRP_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Motion_Hub_2_BldRoot, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Load_BldRoot_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Load_Hub_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshMapsData%Load_Twr_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackMeshMaps(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshMaps), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshMaps'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Twr) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_Hub_2_BldRoot) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_BldRoot_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Hub_2_PRP) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Twr_2_PRP) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshMaps(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshMaps), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshMaps'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Twr) ! Motion_PRP_2_Twr 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Hub) ! Motion_PRP_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_Hub_2_BldRoot) ! Motion_Hub_2_BldRoot 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_BldRoot_2_Hub) ! Load_BldRoot_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Hub_2_PRP) ! Load_Hub_2_PRP 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Twr_2_PRP) ! Load_Twr_2_PRP 
end subroutine
END MODULE WaveTank_Types
!ENDOFREGISTRYGENERATEDFILE
