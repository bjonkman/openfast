!STARTOFREGISTRYGENERATEDFILE 'WaveTank_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WaveTank_Types
!.................................................................................................................................
! This file is part of WaveTank.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WaveTank. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WaveTank_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE ISO_C_BINDING
USE NWTC_Library
IMPLICIT NONE
! =========  SimType  =======
  TYPE, PUBLIC :: SimType
    REAL(c_double)  :: DT = 0.0_R8Ki      !< timestep [-]
    REAL(c_double)  :: TMax = 0.0_R8Ki      !< Max sim time [-]
    INTEGER(c_int)  :: MHK = 0_IntKi      !< MHK turbine type (switch) {0=Not an MHK turbine; 1=Fixed MHK turbine; 2=Floating MHK turbine} [(-)]
    INTEGER(c_int)  :: InterpOrd = 1      !< Interpolation order [-]
    REAL(c_float)  :: ScaleFact = 1      !< scaling factor for scaling full size model to wavetank scale results (>1) [(-)]
    INTEGER(c_int)  :: DebugLevel = 0_IntKi      !< Debug level for outputs [-]
    character(1024)  :: OutRootName      !< Rootname for outputs [-]
  END TYPE SimType
! =======================
! =========  EnvType  =======
  TYPE, PUBLIC :: EnvType
    REAL(c_float)  :: Gravity = 0.0_R4Ki      !< gravitational constant (positive for down) [(m/s^2)]
    REAL(c_float)  :: WtrDens = 0.0_R4Ki      !< Water density [(kg/m^3)]
    REAL(c_float)  :: WtrVisc = 0.0_R4Ki      !< fluid viscosity [(m^2/s)]
    REAL(c_float)  :: SpdSound = 0.0_R4Ki      !< Speed of sound in working fluid [(m/s)]
    REAL(c_float)  :: Patm = 0.0_R4Ki      !< Atmospheric pressure  [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: Pvap = 0.0_R4Ki      !< Vapour pressure of working fluid [used only for an MHK turbine cavitation check] [(Pa)]
    REAL(c_float)  :: WtrDpth = 0.0_R4Ki      !< Water depth [(m)]
    REAL(c_float)  :: MSL2SWL = 0.0_R4Ki      !< Mean sea level to still water level [(m)]
  END TYPE EnvType
! =======================
! =========  TurbConfigType  =======
  TYPE, PUBLIC :: TurbConfigType
    INTEGER(c_int)  :: NumBl = 0_IntKi      !< Number of blades [(-)]
    REAL(c_float)  :: TipRad = 0.0_R4Ki      !< The distance from the rotor apex to the blade tip [(m)]
    REAL(c_float)  :: HubRad = 0.0_R4Ki      !< The distance from the rotor apex to the blade root [(m)]
    REAL(c_float)  :: PreCone = 0.0_R4Ki      !< Blade cone angle [(deg)]
    REAL(c_float)  :: OverHang = 0.0_R4Ki      !< Distance from yaw axis to rotor apex [3 blades] or teeter pin [2 blades] [(m)]
    REAL(c_float)  :: ShftGagL = 0.0_R4Ki      !< Distance from rotor apex [3 blades] or teeter pin [2 blades] to shaft strain gages [positive for upwind rotors] [(m)]
    REAL(c_float)  :: ShftTilt = 0.0_R4Ki      !< Rotor shaft tilt angle [(deg)]
    REAL(c_float)  :: Twr2Shft = 0.0_R4Ki      !< Vertical distance from the tower-top to the rotor shaft [(m)]
    REAL(c_float)  :: TowerHt = 0.0_R4Ki      !< Height of tower relative MSL [(m)]
    REAL(c_float) , DIMENSION(1:3)  :: TowerBsPt = 0.0_R4Ki      !< Tower base location relative to MSL. Consider absolute difference to PtfmRef [floating MHK] [(m)]
    REAL(c_float) , DIMENSION(1:3)  :: PtfmRef = 0.0_R4Ki      !< Location of platform reference point, relative to MSL.  Motions and loads all connect to this point [(m)]
  END TYPE TurbConfigType
! =======================
! =========  TurbOpPointType  =======
  TYPE, PUBLIC :: TurbOpPointType
    REAL(c_float)  :: RotSpeed = 0.0_R4Ki      !< Rotor speed [(RPM)]
    REAL(c_float)  :: NacYaw = 0.0_R4Ki      !< Initial or fixed nacelle-yaw angle [(deg)]
    REAL(c_float)  :: BldPitch = 0.0_R4Ki      !< Fixed blade pitch for full simulation [(deg)]
  END TYPE TurbOpPointType
! =======================
! =========  OutFilesType  =======
  TYPE, PUBLIC :: OutFilesType
    LOGICAL  :: SendScreenToFile = .false.      !< send to file <OutRootName>.screen.log if true [(-)]
    INTEGER(c_int)  :: OutFile = 0_IntKi      !< 0: no output file of channels, 1: output file in text format (at DT) [(-)]
    character(20)  :: OutFmt      !< Format used for text tabular output, excluding the time channel. (quoted string) [(-)]
  END TYPE OutFilesType
! =======================
! =========  VizType  =======
  TYPE, PUBLIC :: VizType
    INTEGER(c_int)  :: WrVTK = 0_IntKi      !< Write VTK? [-]
    INTEGER(c_int)  :: WrVTK_type = 0_IntKi      !< Write VTK outputs as [1: surface, 2: lines, 3: both] [-]
    REAL(c_double)  :: WrVTK_DT = 0.0_R8Ki      !< Time step between VTK writes [-]
    character(1024)  :: WrVTK_dir      !< Directory for VTK writing [-]
    REAL(c_float) , DIMENSION(1:6)  :: VTKNacDim = 0.0_R4Ki      !< Nacelle dimension passed in for VTK surface rendering [0,y0,z0,Lx,Ly,Lz] [(m)]
  END TYPE VizType
! =======================
! =========  IptFilesType  =======
  TYPE, PUBLIC :: IptFilesType
    character(1024)  :: SS_InputFile      !< SeaState   input file [(-)]
    character(1024)  :: MD_InputFile      !< MoorDyn    input file [(-)]
    character(1024)  :: AD_InputFile      !< AeroDyn    input file [(-)]
    character(1024)  :: IfW_InputFile      !< InflowWind input file [(-)]
  END TYPE IptFilesType
! =======================
! =========  SimSettingsType  =======
  TYPE, PUBLIC :: SimSettingsType
    TYPE(SimType)  :: Sim      !< Simulation settings [-]
    TYPE(EnvType)  :: Env      !< Environment settings [-]
    TYPE(TurbConfigType)  :: TCfg      !< Turbine configuration [-]
    TYPE(TurbOpPointType)  :: TOp      !< Turbine operating point [-]
    TYPE(OutFilesType)  :: Outs      !< Output settings [-]
    TYPE(VizType)  :: Viz      !< Vizualization settings [-]
    TYPE(IptFilesType)  :: IptFile      !< Input files for each module [-]
  END TYPE SimSettingsType
! =======================
! =========  CalcStepIOdataType  =======
  TYPE, PUBLIC :: CalcStepIOdataType
    REAL(c_double)  :: Time_c = 0.0_R8Ki      !< IN:  time [(s)]
    REAL(c_float) , DIMENSION(1:6)  :: PosAng_c = 0.0_R4Ki      !< IN:  Position + Euler Ang [x,y,z,phi,theta,psi] [[(m) (rad)]]
    REAL(c_float) , DIMENSION(1:6)  :: Vel_c = 0.0_R4Ki      !< IN:  Velocity             [Vx,Vy,Vz,RVx,RVy,RVz] [[(m/s) (rad/s)]]
    REAL(c_float) , DIMENSION(1:6)  :: Acc_c = 0.0_R4Ki      !< IN:  Acceleration         [Ax,Ay,Az,RAx,RAy,RAz] [[(m/s^2) (rad/s^2)]]
    REAL(c_float) , DIMENSION(1:6)  :: FrcMom_c = 0.0_R4Ki      !< OUT: Acceleration         [Fx,Fy,Fz,Mx,My,Mz] [[(N) (N-m)]]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_SS = 0.0_ReKi      !< calculated forces/moments from SS [-]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_MD = 0.0_ReKi      !< calculated forces/moments from MD [-]
    REAL(ReKi) , DIMENSION(1:6)  :: FrcMom_ADI = 0.0_ReKi      !< calculated forces/moments from ADI [-]
  END TYPE CalcStepIOdataType
! =======================
! =========  WrOutputDataType  =======
  TYPE, PUBLIC :: WrOutputDataType
    INTEGER(IntKi)  :: NumChans_cbind = 0      !< Number of output channels from c-bind [-]
    INTEGER(IntKi)  :: NumChans_SS = 0      !< Number of output channels from SS [-]
    INTEGER(IntKi)  :: NumChans_MD = 0      !< Number of output channels from MD [-]
    INTEGER(IntKi)  :: NumChans_ADI = 0      !< Number of output channels from ADI [-]
    INTEGER(IntKi)  :: NumChans_all = 0      !< Total number of channels (sum of above) [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_SS      !< output file header names from SS [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_SS      !< output file header units from SS [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_MD      !< output file header names from MD [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_MD      !< output file header units from MD [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr_ADI      !< output file header names from ADI [-]
    character(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt_ADI      !< output file header units from ADI [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_SS      !< output data from SS [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_MD      !< output data from MD [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutData_ADI      !< output data from ADI [-]
    character(1024)  :: OutName      !< Output file name [-]
    INTEGER(IntKi)  :: OutUn = -1      !< Output unit [-]
  END TYPE WrOutputDataType
! =======================
! =========  MeshesMotion  =======
  TYPE, PUBLIC :: MeshesMotion
    TYPE(MeshType)  :: PtfmPRPMotion      !< Platform principle ref point. Also serves as tower base [-]
    TYPE(MeshType)  :: TowerMotion      !< Tower mesh (used only for vis) [-]
    TYPE(MeshType)  :: HubMotion      !< Hub mesh (for mappings, no loadings) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootMotion      !< Blade root motions [-]
  END TYPE MeshesMotion
! =======================
! =========  MeshesLoads  =======
  TYPE, PUBLIC :: MeshesLoads
    TYPE(MeshType)  :: PtfmPRPLoads      !< Platform principle ref point loads output [-]
    TYPE(MeshType)  :: TowerLoads      !< Tower mesh (unused) [-]
    TYPE(MeshType)  :: HubLoads      !< Hub mesh (for mappings, intermediate loads) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootLoads      !< Blade root loads [-]
  END TYPE MeshesLoads
! =======================
! =========  MeshesMaps  =======
  TYPE, PUBLIC :: MeshesMaps
    TYPE(MeshMapType)  :: Motion_PRP_2_Twr      !< PRP to tower motion [-]
    TYPE(MeshMapType)  :: Motion_PRP_2_Hub      !< Twrtop to nacelle - add rotation afterwards [-]
    TYPE(MeshMapType)  :: Motion_Hub_2_BldRoot      !< Hub to blade root motion transfer [-]
    TYPE(MeshMapType)  :: Load_BldRoot_2_Hub      !< Blade root loads to hub [-]
    TYPE(MeshMapType)  :: Load_Hub_2_PRP      !< Hub to nacelle load transfer [-]
    TYPE(MeshMapType)  :: Load_Twr_2_PRP      !< Tower loads to PRP (unused) [-]
  END TYPE MeshesMaps
! =======================
CONTAINS

subroutine WT_CopySimType(SrcSimTypeData, DstSimTypeData, CtrlCode, ErrStat, ErrMsg)
   type(SimType), intent(in) :: SrcSimTypeData
   type(SimType), intent(inout) :: DstSimTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopySimType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstSimTypeData%DT = SrcSimTypeData%DT
   DstSimTypeData%TMax = SrcSimTypeData%TMax
   DstSimTypeData%MHK = SrcSimTypeData%MHK
   DstSimTypeData%InterpOrd = SrcSimTypeData%InterpOrd
   DstSimTypeData%ScaleFact = SrcSimTypeData%ScaleFact
   DstSimTypeData%DebugLevel = SrcSimTypeData%DebugLevel
   DstSimTypeData%OutRootName = SrcSimTypeData%OutRootName
end subroutine

subroutine WT_DestroySimType(SimTypeData, ErrStat, ErrMsg)
   type(SimType), intent(inout) :: SimTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroySimType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackSimType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SimType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSimType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%TMax)
   call RegPack(RF, InData%MHK)
   call RegPack(RF, InData%InterpOrd)
   call RegPack(RF, InData%ScaleFact)
   call RegPack(RF, InData%DebugLevel)
   call RegPack(RF, InData%OutRootName)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSimType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SimType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSimType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TMax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ScaleFact); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DebugLevel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutRootName); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyEnvType(SrcEnvTypeData, DstEnvTypeData, CtrlCode, ErrStat, ErrMsg)
   type(EnvType), intent(in) :: SrcEnvTypeData
   type(EnvType), intent(inout) :: DstEnvTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyEnvType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstEnvTypeData%Gravity = SrcEnvTypeData%Gravity
   DstEnvTypeData%WtrDens = SrcEnvTypeData%WtrDens
   DstEnvTypeData%WtrVisc = SrcEnvTypeData%WtrVisc
   DstEnvTypeData%SpdSound = SrcEnvTypeData%SpdSound
   DstEnvTypeData%Patm = SrcEnvTypeData%Patm
   DstEnvTypeData%Pvap = SrcEnvTypeData%Pvap
   DstEnvTypeData%WtrDpth = SrcEnvTypeData%WtrDpth
   DstEnvTypeData%MSL2SWL = SrcEnvTypeData%MSL2SWL
end subroutine

subroutine WT_DestroyEnvType(EnvTypeData, ErrStat, ErrMsg)
   type(EnvType), intent(inout) :: EnvTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyEnvType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackEnvType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(EnvType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackEnvType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%WtrDens)
   call RegPack(RF, InData%WtrVisc)
   call RegPack(RF, InData%SpdSound)
   call RegPack(RF, InData%Patm)
   call RegPack(RF, InData%Pvap)
   call RegPack(RF, InData%WtrDpth)
   call RegPack(RF, InData%MSL2SWL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackEnvType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(EnvType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackEnvType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SpdSound); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Patm); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pvap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MSL2SWL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbConfigType(SrcTurbConfigTypeData, DstTurbConfigTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TurbConfigType), intent(in) :: SrcTurbConfigTypeData
   type(TurbConfigType), intent(inout) :: DstTurbConfigTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbConfigType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbConfigTypeData%NumBl = SrcTurbConfigTypeData%NumBl
   DstTurbConfigTypeData%TipRad = SrcTurbConfigTypeData%TipRad
   DstTurbConfigTypeData%HubRad = SrcTurbConfigTypeData%HubRad
   DstTurbConfigTypeData%PreCone = SrcTurbConfigTypeData%PreCone
   DstTurbConfigTypeData%OverHang = SrcTurbConfigTypeData%OverHang
   DstTurbConfigTypeData%ShftGagL = SrcTurbConfigTypeData%ShftGagL
   DstTurbConfigTypeData%ShftTilt = SrcTurbConfigTypeData%ShftTilt
   DstTurbConfigTypeData%Twr2Shft = SrcTurbConfigTypeData%Twr2Shft
   DstTurbConfigTypeData%TowerHt = SrcTurbConfigTypeData%TowerHt
   DstTurbConfigTypeData%TowerBsPt = SrcTurbConfigTypeData%TowerBsPt
   DstTurbConfigTypeData%PtfmRef = SrcTurbConfigTypeData%PtfmRef
end subroutine

subroutine WT_DestroyTurbConfigType(TurbConfigTypeData, ErrStat, ErrMsg)
   type(TurbConfigType), intent(inout) :: TurbConfigTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbConfigType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbConfigType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbConfigType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbConfigType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumBl)
   call RegPack(RF, InData%TipRad)
   call RegPack(RF, InData%HubRad)
   call RegPack(RF, InData%PreCone)
   call RegPack(RF, InData%OverHang)
   call RegPack(RF, InData%ShftGagL)
   call RegPack(RF, InData%ShftTilt)
   call RegPack(RF, InData%Twr2Shft)
   call RegPack(RF, InData%TowerHt)
   call RegPack(RF, InData%TowerBsPt)
   call RegPack(RF, InData%PtfmRef)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbConfigType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbConfigType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbConfigType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumBl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TipRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PreCone); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OverHang); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShftGagL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShftTilt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Twr2Shft); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerHt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TowerBsPt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmRef); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyTurbOpPointType(SrcTurbOpPointTypeData, DstTurbOpPointTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TurbOpPointType), intent(in) :: SrcTurbOpPointTypeData
   type(TurbOpPointType), intent(inout) :: DstTurbOpPointTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyTurbOpPointType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbOpPointTypeData%RotSpeed = SrcTurbOpPointTypeData%RotSpeed
   DstTurbOpPointTypeData%NacYaw = SrcTurbOpPointTypeData%NacYaw
   DstTurbOpPointTypeData%BldPitch = SrcTurbOpPointTypeData%BldPitch
end subroutine

subroutine WT_DestroyTurbOpPointType(TurbOpPointTypeData, ErrStat, ErrMsg)
   type(TurbOpPointType), intent(inout) :: TurbOpPointTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyTurbOpPointType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackTurbOpPointType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbOpPointType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackTurbOpPointType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%NacYaw)
   call RegPack(RF, InData%BldPitch)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackTurbOpPointType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbOpPointType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackTurbOpPointType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NacYaw); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BldPitch); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyOutFilesType(SrcOutFilesTypeData, DstOutFilesTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutFilesType), intent(in) :: SrcOutFilesTypeData
   type(OutFilesType), intent(inout) :: DstOutFilesTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyOutFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutFilesTypeData%SendScreenToFile = SrcOutFilesTypeData%SendScreenToFile
   DstOutFilesTypeData%OutFile = SrcOutFilesTypeData%OutFile
   DstOutFilesTypeData%OutFmt = SrcOutFilesTypeData%OutFmt
end subroutine

subroutine WT_DestroyOutFilesType(OutFilesTypeData, ErrStat, ErrMsg)
   type(OutFilesType), intent(inout) :: OutFilesTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyOutFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackOutFilesType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OutFilesType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackOutFilesType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SendScreenToFile)
   call RegPack(RF, InData%OutFile)
   call RegPack(RF, InData%OutFmt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackOutFilesType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OutFilesType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackOutFilesType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SendScreenToFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFmt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyVizType(SrcVizTypeData, DstVizTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VizType), intent(in) :: SrcVizTypeData
   type(VizType), intent(inout) :: DstVizTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyVizType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVizTypeData%WrVTK = SrcVizTypeData%WrVTK
   DstVizTypeData%WrVTK_type = SrcVizTypeData%WrVTK_type
   DstVizTypeData%WrVTK_DT = SrcVizTypeData%WrVTK_DT
   DstVizTypeData%WrVTK_dir = SrcVizTypeData%WrVTK_dir
   DstVizTypeData%VTKNacDim = SrcVizTypeData%VTKNacDim
end subroutine

subroutine WT_DestroyVizType(VizTypeData, ErrStat, ErrMsg)
   type(VizType), intent(inout) :: VizTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyVizType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackVizType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VizType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackVizType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%WrVTK)
   call RegPack(RF, InData%WrVTK_type)
   call RegPack(RF, InData%WrVTK_DT)
   call RegPack(RF, InData%WrVTK_dir)
   call RegPack(RF, InData%VTKNacDim)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackVizType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VizType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackVizType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%WrVTK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK_dir); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKNacDim); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyIptFilesType(SrcIptFilesTypeData, DstIptFilesTypeData, CtrlCode, ErrStat, ErrMsg)
   type(IptFilesType), intent(in) :: SrcIptFilesTypeData
   type(IptFilesType), intent(inout) :: DstIptFilesTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyIptFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstIptFilesTypeData%SS_InputFile = SrcIptFilesTypeData%SS_InputFile
   DstIptFilesTypeData%MD_InputFile = SrcIptFilesTypeData%MD_InputFile
   DstIptFilesTypeData%AD_InputFile = SrcIptFilesTypeData%AD_InputFile
   DstIptFilesTypeData%IfW_InputFile = SrcIptFilesTypeData%IfW_InputFile
end subroutine

subroutine WT_DestroyIptFilesType(IptFilesTypeData, ErrStat, ErrMsg)
   type(IptFilesType), intent(inout) :: IptFilesTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyIptFilesType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackIptFilesType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(IptFilesType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackIptFilesType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SS_InputFile)
   call RegPack(RF, InData%MD_InputFile)
   call RegPack(RF, InData%AD_InputFile)
   call RegPack(RF, InData%IfW_InputFile)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackIptFilesType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(IptFilesType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackIptFilesType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SS_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MD_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AD_InputFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IfW_InputFile); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopySimSettingsType(SrcSimSettingsTypeData, DstSimSettingsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(SimSettingsType), intent(in) :: SrcSimSettingsTypeData
   type(SimSettingsType), intent(inout) :: DstSimSettingsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_CopySimType(SrcSimSettingsTypeData%Sim, DstSimSettingsTypeData%Sim, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyEnvType(SrcSimSettingsTypeData%Env, DstSimSettingsTypeData%Env, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbConfigType(SrcSimSettingsTypeData%TCfg, DstSimSettingsTypeData%TCfg, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyTurbOpPointType(SrcSimSettingsTypeData%TOp, DstSimSettingsTypeData%TOp, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyOutFilesType(SrcSimSettingsTypeData%Outs, DstSimSettingsTypeData%Outs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyVizType(SrcSimSettingsTypeData%Viz, DstSimSettingsTypeData%Viz, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WT_CopyIptFilesType(SrcSimSettingsTypeData%IptFile, DstSimSettingsTypeData%IptFile, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroySimSettingsType(SimSettingsTypeData, ErrStat, ErrMsg)
   type(SimSettingsType), intent(inout) :: SimSettingsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroySimSettingsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WT_DestroySimType(SimSettingsTypeData%Sim, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyEnvType(SimSettingsTypeData%Env, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbConfigType(SimSettingsTypeData%TCfg, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyTurbOpPointType(SimSettingsTypeData%TOp, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyOutFilesType(SimSettingsTypeData%Outs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyVizType(SimSettingsTypeData%Viz, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WT_DestroyIptFilesType(SimSettingsTypeData%IptFile, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackSimSettingsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SimSettingsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackSimSettingsType'
   if (RF%ErrStat >= AbortErrLev) return
   call WT_PackSimType(RF, InData%Sim) 
   call WT_PackEnvType(RF, InData%Env) 
   call WT_PackTurbConfigType(RF, InData%TCfg) 
   call WT_PackTurbOpPointType(RF, InData%TOp) 
   call WT_PackOutFilesType(RF, InData%Outs) 
   call WT_PackVizType(RF, InData%Viz) 
   call WT_PackIptFilesType(RF, InData%IptFile) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackSimSettingsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SimSettingsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackSimSettingsType'
   if (RF%ErrStat /= ErrID_None) return
   call WT_UnpackSimType(RF, OutData%Sim) ! Sim 
   call WT_UnpackEnvType(RF, OutData%Env) ! Env 
   call WT_UnpackTurbConfigType(RF, OutData%TCfg) ! TCfg 
   call WT_UnpackTurbOpPointType(RF, OutData%TOp) ! TOp 
   call WT_UnpackOutFilesType(RF, OutData%Outs) ! Outs 
   call WT_UnpackVizType(RF, OutData%Viz) ! Viz 
   call WT_UnpackIptFilesType(RF, OutData%IptFile) ! IptFile 
end subroutine

subroutine WT_CopyCalcStepIOdataType(SrcCalcStepIOdataTypeData, DstCalcStepIOdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(CalcStepIOdataType), intent(in) :: SrcCalcStepIOdataTypeData
   type(CalcStepIOdataType), intent(inout) :: DstCalcStepIOdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_CopyCalcStepIOdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstCalcStepIOdataTypeData%Time_c = SrcCalcStepIOdataTypeData%Time_c
   DstCalcStepIOdataTypeData%PosAng_c = SrcCalcStepIOdataTypeData%PosAng_c
   DstCalcStepIOdataTypeData%Vel_c = SrcCalcStepIOdataTypeData%Vel_c
   DstCalcStepIOdataTypeData%Acc_c = SrcCalcStepIOdataTypeData%Acc_c
   DstCalcStepIOdataTypeData%FrcMom_c = SrcCalcStepIOdataTypeData%FrcMom_c
   DstCalcStepIOdataTypeData%FrcMom_SS = SrcCalcStepIOdataTypeData%FrcMom_SS
   DstCalcStepIOdataTypeData%FrcMom_MD = SrcCalcStepIOdataTypeData%FrcMom_MD
   DstCalcStepIOdataTypeData%FrcMom_ADI = SrcCalcStepIOdataTypeData%FrcMom_ADI
end subroutine

subroutine WT_DestroyCalcStepIOdataType(CalcStepIOdataTypeData, ErrStat, ErrMsg)
   type(CalcStepIOdataType), intent(inout) :: CalcStepIOdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyCalcStepIOdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine WT_PackCalcStepIOdataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(CalcStepIOdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackCalcStepIOdataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Time_c)
   call RegPack(RF, InData%PosAng_c)
   call RegPack(RF, InData%Vel_c)
   call RegPack(RF, InData%Acc_c)
   call RegPack(RF, InData%FrcMom_c)
   call RegPack(RF, InData%FrcMom_SS)
   call RegPack(RF, InData%FrcMom_MD)
   call RegPack(RF, InData%FrcMom_ADI)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackCalcStepIOdataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(CalcStepIOdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackCalcStepIOdataType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Time_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PosAng_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vel_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Acc_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_c); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FrcMom_ADI); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyWrOutputDataType(SrcWrOutputDataTypeData, DstWrOutputDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(WrOutputDataType), intent(in) :: SrcWrOutputDataTypeData
   type(WrOutputDataType), intent(inout) :: DstWrOutputDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'WT_CopyWrOutputDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWrOutputDataTypeData%NumChans_cbind = SrcWrOutputDataTypeData%NumChans_cbind
   DstWrOutputDataTypeData%NumChans_SS = SrcWrOutputDataTypeData%NumChans_SS
   DstWrOutputDataTypeData%NumChans_MD = SrcWrOutputDataTypeData%NumChans_MD
   DstWrOutputDataTypeData%NumChans_ADI = SrcWrOutputDataTypeData%NumChans_ADI
   DstWrOutputDataTypeData%NumChans_all = SrcWrOutputDataTypeData%NumChans_all
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_SS)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_SS)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_SS = SrcWrOutputDataTypeData%WriteOutputHdr_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_SS)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_SS)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_SS = SrcWrOutputDataTypeData%WriteOutputUnt_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_MD)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_MD)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_MD = SrcWrOutputDataTypeData%WriteOutputHdr_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_MD)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_MD)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_MD = SrcWrOutputDataTypeData%WriteOutputUnt_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputHdr_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputHdr_ADI)) then
         allocate(DstWrOutputDataTypeData%WriteOutputHdr_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputHdr_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputHdr_ADI = SrcWrOutputDataTypeData%WriteOutputHdr_ADI
   end if
   if (allocated(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%WriteOutputUnt_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%WriteOutputUnt_ADI)) then
         allocate(DstWrOutputDataTypeData%WriteOutputUnt_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%WriteOutputUnt_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%WriteOutputUnt_ADI = SrcWrOutputDataTypeData%WriteOutputUnt_ADI
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_SS)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_SS)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_SS)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_SS)) then
         allocate(DstWrOutputDataTypeData%OutData_SS(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_SS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_SS = SrcWrOutputDataTypeData%OutData_SS
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_MD)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_MD)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_MD)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_MD)) then
         allocate(DstWrOutputDataTypeData%OutData_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_MD = SrcWrOutputDataTypeData%OutData_MD
   end if
   if (allocated(SrcWrOutputDataTypeData%OutData_ADI)) then
      LB(1:1) = lbound(SrcWrOutputDataTypeData%OutData_ADI)
      UB(1:1) = ubound(SrcWrOutputDataTypeData%OutData_ADI)
      if (.not. allocated(DstWrOutputDataTypeData%OutData_ADI)) then
         allocate(DstWrOutputDataTypeData%OutData_ADI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWrOutputDataTypeData%OutData_ADI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWrOutputDataTypeData%OutData_ADI = SrcWrOutputDataTypeData%OutData_ADI
   end if
   DstWrOutputDataTypeData%OutName = SrcWrOutputDataTypeData%OutName
   DstWrOutputDataTypeData%OutUn = SrcWrOutputDataTypeData%OutUn
end subroutine

subroutine WT_DestroyWrOutputDataType(WrOutputDataTypeData, ErrStat, ErrMsg)
   type(WrOutputDataType), intent(inout) :: WrOutputDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'WT_DestroyWrOutputDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_SS)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_SS)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_SS)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_SS)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_MD)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_MD)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_MD)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_MD)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputHdr_ADI)) then
      deallocate(WrOutputDataTypeData%WriteOutputHdr_ADI)
   end if
   if (allocated(WrOutputDataTypeData%WriteOutputUnt_ADI)) then
      deallocate(WrOutputDataTypeData%WriteOutputUnt_ADI)
   end if
   if (allocated(WrOutputDataTypeData%OutData_SS)) then
      deallocate(WrOutputDataTypeData%OutData_SS)
   end if
   if (allocated(WrOutputDataTypeData%OutData_MD)) then
      deallocate(WrOutputDataTypeData%OutData_MD)
   end if
   if (allocated(WrOutputDataTypeData%OutData_ADI)) then
      deallocate(WrOutputDataTypeData%OutData_ADI)
   end if
end subroutine

subroutine WT_PackWrOutputDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(WrOutputDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackWrOutputDataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumChans_cbind)
   call RegPack(RF, InData%NumChans_SS)
   call RegPack(RF, InData%NumChans_MD)
   call RegPack(RF, InData%NumChans_ADI)
   call RegPack(RF, InData%NumChans_all)
   call RegPackAlloc(RF, InData%WriteOutputHdr_SS)
   call RegPackAlloc(RF, InData%WriteOutputUnt_SS)
   call RegPackAlloc(RF, InData%WriteOutputHdr_MD)
   call RegPackAlloc(RF, InData%WriteOutputUnt_MD)
   call RegPackAlloc(RF, InData%WriteOutputHdr_ADI)
   call RegPackAlloc(RF, InData%WriteOutputUnt_ADI)
   call RegPackAlloc(RF, InData%OutData_SS)
   call RegPackAlloc(RF, InData%OutData_MD)
   call RegPackAlloc(RF, InData%OutData_ADI)
   call RegPack(RF, InData%OutName)
   call RegPack(RF, InData%OutUn)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackWrOutputDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(WrOutputDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackWrOutputDataType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumChans_cbind); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans_all); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_SS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_MD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutData_ADI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutUn); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_CopyMeshesMotion(SrcMeshesMotionData, DstMeshesMotionData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesMotion), intent(inout) :: SrcMeshesMotionData
   type(MeshesMotion), intent(inout) :: DstMeshesMotionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesMotion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMeshesMotionData%PtfmPRPMotion, DstMeshesMotionData%PtfmPRPMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionData%TowerMotion, DstMeshesMotionData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesMotionData%HubMotion, DstMeshesMotionData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMeshesMotionData%BladeRootMotion)) then
      LB(1:1) = lbound(SrcMeshesMotionData%BladeRootMotion)
      UB(1:1) = ubound(SrcMeshesMotionData%BladeRootMotion)
      if (.not. allocated(DstMeshesMotionData%BladeRootMotion)) then
         allocate(DstMeshesMotionData%BladeRootMotion(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshesMotionData%BladeRootMotion.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshesMotionData%BladeRootMotion(i1), DstMeshesMotionData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine WT_DestroyMeshesMotion(MeshesMotionData, ErrStat, ErrMsg)
   type(MeshesMotion), intent(inout) :: MeshesMotionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesMotion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MeshesMotionData%PtfmPRPMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionData%TowerMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesMotionData%HubMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MeshesMotionData%BladeRootMotion)) then
      LB(1:1) = lbound(MeshesMotionData%BladeRootMotion)
      UB(1:1) = ubound(MeshesMotionData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshesMotionData%BladeRootMotion(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshesMotionData%BladeRootMotion)
   end if
end subroutine

subroutine WT_PackMeshesMotion(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesMotion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesMotion'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPRPMotion) 
   call MeshPack(RF, InData%TowerMotion) 
   call MeshPack(RF, InData%HubMotion) 
   call RegPack(RF, allocated(InData%BladeRootMotion))
   if (allocated(InData%BladeRootMotion)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootMotion), ubound(InData%BladeRootMotion))
      LB(1:1) = lbound(InData%BladeRootMotion)
      UB(1:1) = ubound(InData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootMotion(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesMotion(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesMotion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesMotion'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPRPMotion) ! PtfmPRPMotion 
   call MeshUnpack(RF, OutData%TowerMotion) ! TowerMotion 
   call MeshUnpack(RF, OutData%HubMotion) ! HubMotion 
   if (allocated(OutData%BladeRootMotion)) deallocate(OutData%BladeRootMotion)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootMotion(i1)) ! BladeRootMotion 
      end do
   end if
end subroutine

subroutine WT_CopyMeshesLoads(SrcMeshesLoadsData, DstMeshesLoadsData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesLoads), intent(inout) :: SrcMeshesLoadsData
   type(MeshesLoads), intent(inout) :: DstMeshesLoadsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcMeshesLoadsData%PtfmPRPLoads, DstMeshesLoadsData%PtfmPRPLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesLoadsData%TowerLoads, DstMeshesLoadsData%TowerLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMeshesLoadsData%HubLoads, DstMeshesLoadsData%HubLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMeshesLoadsData%BladeRootLoads)) then
      LB(1:1) = lbound(SrcMeshesLoadsData%BladeRootLoads)
      UB(1:1) = ubound(SrcMeshesLoadsData%BladeRootLoads)
      if (.not. allocated(DstMeshesLoadsData%BladeRootLoads)) then
         allocate(DstMeshesLoadsData%BladeRootLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshesLoadsData%BladeRootLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshesLoadsData%BladeRootLoads(i1), DstMeshesLoadsData%BladeRootLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine WT_DestroyMeshesLoads(MeshesLoadsData, ErrStat, ErrMsg)
   type(MeshesLoads), intent(inout) :: MeshesLoadsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( MeshesLoadsData%PtfmPRPLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesLoadsData%TowerLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MeshesLoadsData%HubLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MeshesLoadsData%BladeRootLoads)) then
      LB(1:1) = lbound(MeshesLoadsData%BladeRootLoads)
      UB(1:1) = ubound(MeshesLoadsData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshesLoadsData%BladeRootLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshesLoadsData%BladeRootLoads)
   end if
end subroutine

subroutine WT_PackMeshesLoads(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesLoads), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesLoads'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%PtfmPRPLoads) 
   call MeshPack(RF, InData%TowerLoads) 
   call MeshPack(RF, InData%HubLoads) 
   call RegPack(RF, allocated(InData%BladeRootLoads))
   if (allocated(InData%BladeRootLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeRootLoads), ubound(InData%BladeRootLoads))
      LB(1:1) = lbound(InData%BladeRootLoads)
      UB(1:1) = ubound(InData%BladeRootLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BladeRootLoads(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesLoads(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesLoads), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesLoads'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%PtfmPRPLoads) ! PtfmPRPLoads 
   call MeshUnpack(RF, OutData%TowerLoads) ! TowerLoads 
   call MeshUnpack(RF, OutData%HubLoads) ! HubLoads 
   if (allocated(OutData%BladeRootLoads)) deallocate(OutData%BladeRootLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeRootLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BladeRootLoads(i1)) ! BladeRootLoads 
      end do
   end if
end subroutine

subroutine WT_CopyMeshesMaps(SrcMeshesMapsData, DstMeshesMapsData, CtrlCode, ErrStat, ErrMsg)
   type(MeshesMaps), intent(inout) :: SrcMeshesMapsData
   type(MeshesMaps), intent(inout) :: DstMeshesMapsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_CopyMeshesMaps'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Motion_PRP_2_Twr, DstMeshesMapsData%Motion_PRP_2_Twr, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Motion_PRP_2_Hub, DstMeshesMapsData%Motion_PRP_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Motion_Hub_2_BldRoot, DstMeshesMapsData%Motion_Hub_2_BldRoot, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Load_BldRoot_2_Hub, DstMeshesMapsData%Load_BldRoot_2_Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Load_Hub_2_PRP, DstMeshesMapsData%Load_Hub_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMeshesMapsData%Load_Twr_2_PRP, DstMeshesMapsData%Load_Twr_2_PRP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine WT_DestroyMeshesMaps(MeshesMapsData, ErrStat, ErrMsg)
   type(MeshesMaps), intent(inout) :: MeshesMapsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'WT_DestroyMeshesMaps'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Motion_PRP_2_Twr, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Motion_PRP_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Motion_Hub_2_BldRoot, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Load_BldRoot_2_Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Load_Hub_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MeshesMapsData%Load_Twr_2_PRP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine WT_PackMeshesMaps(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshesMaps), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WT_PackMeshesMaps'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Twr) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_PRP_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Motion_Hub_2_BldRoot) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_BldRoot_2_Hub) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Hub_2_PRP) 
   call NWTC_Library_PackMeshMapType(RF, InData%Load_Twr_2_PRP) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine WT_UnPackMeshesMaps(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshesMaps), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WT_UnPackMeshesMaps'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Twr) ! Motion_PRP_2_Twr 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_PRP_2_Hub) ! Motion_PRP_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Motion_Hub_2_BldRoot) ! Motion_Hub_2_BldRoot 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_BldRoot_2_Hub) ! Load_BldRoot_2_Hub 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Hub_2_PRP) ! Load_Hub_2_PRP 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%Load_Twr_2_PRP) ! Load_Twr_2_PRP 
end subroutine
END MODULE WaveTank_Types
!ENDOFREGISTRYGENERATEDFILE
